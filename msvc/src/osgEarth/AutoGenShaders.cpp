// ***DO NOT EDIT THIS FILE - IT IS AUTOMATICALLY GENERATED BY CMAKE***

#include <osgEarth/Shaders>

namespace osgEarth
{
    Shaders::Shaders()
    {
        // Clip Plane
        ClipPlane = "ClipPlane.glsl";
        _sources[ClipPlane] = "#version 330%EOL%#pragma vp_name       ClipPlane.glsl%EOL%#pragma vp_entryPoint oe_ClipPlane_VS%EOL%#pragma vp_location   vertex_view%EOL%#pragma vp_order      last%EOL%#pragma import_defines(OE_CLIPPLANE_NUM)%EOL%%EOL%// OSG built-in to transform from view to world%EOL%uniform mat4 osg_ViewMatrixInverse;%EOL%%EOL%// clipping plane%EOL%uniform vec4 oe_ClipPlane_plane;%EOL%%EOL%void oe_ClipPlane_VS(inout vec4 vertex_view)%EOL%{%EOL%#ifndef GL_ES%EOL%    gl_ClipDistance[OE_CLIPPLANE_NUM] = dot(osg_ViewMatrixInverse * vertex_view, oe_ClipPlane_plane);%EOL%#endif%EOL%}%EOL%%EOL%";

        // Depth Offset
        DepthOffsetVertex = "DepthOffset.vert.glsl";
        _sources[DepthOffsetVertex] = "#version $GLSL_VERSION_STR%EOL%$GLSL_DEFAULT_PRECISION_FLOAT%EOL%%EOL%#pragma vp_entryPoint oe_DepthOffset_vertex%EOL%#pragma vp_location   vertex_view%EOL%#pragma vp_order      0.8%EOL%%EOL%uniform vec4 oe_DepthOffset_params;%EOL%%EOL%void oe_DepthOffset_vertex(inout vec4 vertexView)%EOL%{%EOL%    // calculate range to target:%EOL%    float range = length(vertexView.xyz);%EOL%%EOL%    // extract params for clarity.%EOL%    float minBias = oe_DepthOffset_params[0];%EOL%    float maxBias = oe_DepthOffset_params[1];%EOL%    float minRange = oe_DepthOffset_params[2];%EOL%    float maxRange = oe_DepthOffset_params[3];%EOL%%EOL%    // calculate the depth offset bias for this range:%EOL%    float ratio = (clamp(range, minRange, maxRange)-minRange)/(maxRange-minRange);%EOL%    float bias = minBias + ratio * (maxBias-minBias);%EOL%%EOL%	// clamp the bias to 1/2 of the range of the vertex. We don't want to %EOL%    // pull the vertex TOO close to the camera and certainly not behind it.%EOL%    bias = min(bias, range*0.5);%EOL%    bias = min(bias, maxBias);%EOL%%EOL%    // pull the vertex towards the camera.%EOL%    vec3 pullVec = normalize(vertexView.xyz);%EOL%    vec3 simVert3 = vertexView.xyz - pullVec*bias;%EOL%    vertexView = vec4(simVert3, 1.0);%EOL%}%EOL%%EOL%";


        // Draping
        DrapingVertex = "Draping.vert.glsl";
        _sources[DrapingVertex] = "#version $GLSL_VERSION_STR%EOL%$GLSL_DEFAULT_PRECISION_FLOAT%EOL%%EOL%#pragma vp_entryPoint oe_overlay_vertex%EOL%#pragma vp_location   vertex_view%EOL%%EOL%uniform mat4 oe_overlay_texmatrix;%EOL%uniform float oe_overlay_rttLimitZ;%EOL%%EOL%out vec4 oe_overlay_texcoord;%EOL%%EOL%void oe_overlay_vertex(inout vec4 vertexVIEW)%EOL%{%EOL%    oe_overlay_texcoord = oe_overlay_texmatrix * vertexVIEW;%EOL%}%EOL%%EOL%";

        DrapingFragment = "Draping.frag.glsl";
        _sources[DrapingFragment] = "#version $GLSL_VERSION_STR%EOL%$GLSL_DEFAULT_PRECISION_FLOAT%EOL%%EOL%#pragma vp_entryPoint oe_overlay_fragment%EOL%#pragma vp_location   fragment_coloring%EOL%#pragma vp_order      0.6%EOL%%EOL%#pragma import_defines(OE_IS_PICK_CAMERA)%EOL%%EOL%uniform sampler2D oe_overlay_tex;%EOL%in vec4 oe_overlay_texcoord;%EOL%%EOL%void oe_overlay_fragment(inout vec4 color)%EOL%{%EOL%    vec4 texel = textureProj(oe_overlay_tex, oe_overlay_texcoord);%EOL%%EOL%#ifdef OE_IS_PICK_CAMERA%EOL%    color = texel;%EOL%#else%EOL%    color = vec4( mix( color.rgb, texel.rgb, texel.a ), color.a);%EOL%#endif%EOL%}%EOL%%EOL%";


        // GPU Clamping
        GPUClampingVertex = "GPUClamping.vert.glsl";
        _sources[GPUClampingVertex] = "#version $GLSL_VERSION_STR%EOL%$GLSL_DEFAULT_PRECISION_FLOAT%EOL%%EOL%#pragma vp_entryPoint oe_clamp_vertex%EOL%#pragma vp_location   vertex_view%EOL%#pragma vp_order      0.5%EOL%#pragma import_defines(OE_CLAMP_HAS_ATTRIBUTES)%EOL%#pragma import_defines(OE_IS_GEOCENTRIC)%EOL%#pragma include GPUClamping.vert.lib.glsl%EOL%%EOL%#ifdef OE_CLAMP_HAS_ATTRIBUTES%EOL%in vec4 oe_clamp_attrs;     // vertex attribute%EOL%in float oe_clamp_height;   // vertex attribute%EOL%#endif%EOL%%EOL%out float oe_clamp_alpha;%EOL%%EOL%uniform float oe_clamp_altitudeOffset;%EOL%uniform float oe_clamp_horizonDistance2;%EOL%%EOL%void oe_clamp_clampViewSpaceVertex(inout vec4 vertexView)%EOL%{%EOL%#ifdef OE_CLAMP_HAS_ATTRIBUTES%EOL%    bool relativeToAnchor = (oe_clamp_attrs.a == 1.0); // 1.0 = ClampToAnchor%EOL%    float verticalOffset = oe_clamp_attrs.z;%EOL%    float clampHeight = oe_clamp_height;%EOL%%EOL%    // if we are using the anchor point, xform it into view space to prepare%EOL%    // for clamping. Force Z=0 for anchoring.%EOL%    vec4 pointToClamp = relativeToAnchor ?%EOL%        gl_ModelViewMatrix * vec4(oe_clamp_attrs.xy, 0.0, 1.0) :%EOL%        vertexView;%EOL%#else%EOL%    bool relativeToAnchor = false;%EOL%    float verticalOffset = 0.0;%EOL%    vec4 pointToClamp = vertexView;%EOL%    float clampHeight = 0.0;%EOL%#endif%EOL%%EOL%    // clamp the point and remember it's depth:%EOL%    vec4 clampedPoint;%EOL%    float depth;%EOL%    oe_getClampedViewVertex(pointToClamp, clampedPoint, depth);%EOL%%EOL%    float dh = verticalOffset + oe_clamp_altitudeOffset;%EOL%%EOL%    if (relativeToAnchor)%EOL%    {%EOL%        // if we are clamping relative to the anchor point, adjust the HAT based on the%EOL%        // distance from the anchor point to the terrain. Since distance() is unsigned,%EOL%        // we use the vector dot product to calculate whether to adjust up or down.%EOL%        float dist = distance(pointToClamp, clampedPoint);%EOL%        float dir = sign(dot(clampedPoint - pointToClamp, vertexView - pointToClamp));%EOL%        dh += (dist * dir);%EOL%    }%EOL%    else%EOL%    {%EOL%        // if we are clamping to the terrain, the vertex becomes the%EOL%        // clamped point%EOL%        vertexView.xyz = clampedPoint.xyz;%EOL%        dh += clampHeight;%EOL%    }%EOL%%EOL%    // calculate the up vector along which clamping will occur (in either direction)%EOL%    vec3 up;%EOL%    oe_getClampingUpVector(up);%EOL%    vertexView.xyz += up*dh;%EOL%%EOL%    // if the clamped depth value is near the far plane, suppress drawing%EOL%    // to avoid rendering anomalies.%EOL%    oe_clamp_alpha = 1.0 - step(0.9999, depth);%EOL%}%EOL%%EOL%void oe_clamp_vertex(inout vec4 vertexView)%EOL%{%EOL%    // check distance; alpha out if its beyone the horizon distance.%EOL%#ifdef OE_IS_GEOCENTRIC%EOL%    oe_clamp_alpha = clamp(oe_clamp_horizonDistance2 - (vertexView.z*vertexView.z), 0.0, 1.0);%EOL%#else%EOL%    oe_clamp_alpha = 1.0;%EOL%#endif%EOL%%EOL%    // if visible, calculate clamping.%EOL%    // note: no branch divergence in the vertex shader%EOL%    if ( oe_clamp_alpha > 0.0 )%EOL%    {%EOL%        oe_clamp_clampViewSpaceVertex(vertexView);%EOL%    }%EOL%}%EOL%%EOL%";

        GPUClampingFragment = "GPUClamping.frag.glsl";
        _sources[GPUClampingFragment] = "#version $GLSL_VERSION_STR%EOL%$GLSL_DEFAULT_PRECISION_FLOAT%EOL%%EOL%#pragma vp_entryPoint oe_clamp_fragment%EOL%#pragma vp_location   fragment_coloring%EOL%%EOL%in float oe_clamp_alpha;%EOL%%EOL%void oe_clamp_fragment(inout vec4 color)%EOL%{%EOL%    // adjust the alpha component to %QUOTE%hide%QUOTE% geometry beyond the visible horizon.%EOL%    color.a *= oe_clamp_alpha;%EOL%}%EOL%%EOL%";

        GPUClampingVertexLib = "GPUClamping.vert.lib.glsl";
        _sources[GPUClampingVertexLib] = "// note: this is an include file%EOL%%EOL%// depth texture captures by the clamping technique%EOL%uniform sampler2D oe_clamp_depthTex;%EOL%%EOL%// matrix transforming from view space to depth-texture clip space%EOL%uniform mat4 oe_clamp_cameraView2depthClip;%EOL%%EOL%// matrix transform from depth-tecture clip space to view space%EOL%uniform mat4 oe_clamp_depthClip2cameraView;%EOL%%EOL%// Given a vertex in view space, clamp it to the %QUOTE%ground%QUOTE% as represented%EOL%// by an orthographic depth texture. Return the clamped vertex in view space,%EOL%// along with the associated depth value.%EOL%void oe_getClampedViewVertex(in vec4 vertView, out vec4 out_clampedVertView, out float out_depth)%EOL%{%EOL%    // transform the vertex into the depth texture's clip coordinates.%EOL%    vec4 vertDepthClip = oe_clamp_cameraView2depthClip * vertView;%EOL%%EOL%    // sample the depth map%EOL%    out_depth = textureProj( oe_clamp_depthTex, vertDepthClip ).r;%EOL%%EOL%    // now transform into depth-view space so we can apply the height-above-ground:%EOL%    vec4 clampedVertDepthClip = vec4(vertDepthClip.x, vertDepthClip.y, out_depth, 1.0);%EOL%%EOL%    // convert back into view space.%EOL%    out_clampedVertView = oe_clamp_depthClip2cameraView * clampedVertDepthClip;%EOL%}%EOL%%EOL%// Returns a vector indicating the %QUOTE%down%QUOTE% direction.%EOL%void oe_getClampingUpVector(out vec3 up)%EOL%{%EOL%    up = normalize(mat3(oe_clamp_depthClip2cameraView) * vec3(0,0,-1));%EOL%}%EOL%%EOL%";


        // DrawInstanced
        InstancingVertex = "Instancing.vert.glsl";
        _sources[InstancingVertex] = "#version $GLSL_VERSION_STR%EOL%$GLSL_DEFAULT_PRECISION_FLOAT%EOL%%EOL%#extension GL_EXT_gpu_shader4 : enable%EOL%#extension GL_ARB_draw_instanced: enable%EOL%%EOL%#pragma vp_entryPoint oe_di_setInstancePosition%EOL%#pragma vp_location   vertex_model%EOL%#pragma vp_order      0.0%EOL%%EOL%uniform samplerBuffer oe_di_postex_TBO;%EOL%%EOL%// Stage-global containing object ID%EOL%uint oe_index_objectid;%EOL%vec3 vp_Normal;%EOL%%EOL%void oe_di_setInstancePosition(inout vec4 VertexMODEL)%EOL%{ %EOL%    int index = 4 * gl_InstanceID;%EOL%%EOL%    vec4 m0 = texelFetch(oe_di_postex_TBO, index);%EOL%    vec4 m1 = texelFetch(oe_di_postex_TBO, index+1); %EOL%    vec4 m2 = texelFetch(oe_di_postex_TBO, index+2); %EOL%    vec4 m3 = texelFetch(oe_di_postex_TBO, index+3);%EOL%%EOL%    // decode the ObjectID from the last column:%EOL%    %EOL%    oe_index_objectid = uint(m3[0]) + (uint(m3[1]) << 8u) + (uint(m3[2]) << 16u) + (uint(m3[3]) << 24u);%EOL%    %EOL%    // rebuild positioning matrix and transform the vert. (Note, the matrix is actually%EOL%    // transposed so we have to reverse the multiplication order.)%EOL%    mat4 xform = mat4(m0, m1, m2, vec4(0,0,0,1));%EOL%%EOL%    VertexMODEL = VertexMODEL * xform;%EOL%%EOL%    // rotate the normal vector in the same manner.%EOL%    vp_Normal = vp_Normal * mat3(xform);%EOL%}%EOL%%EOL%%EOL%";

        // LineDrawable
        LineDrawable = "LineDrawable.glsl";
        _sources[LineDrawable] = "#version $GLSL_VERSION_STR%EOL%#pragma vp_name GPU Lines Screen Projected Model%EOL%#pragma vp_entryPoint oe_LineDrawable_VS_VIEW%EOL%#pragma vp_location vertex_view%EOL%#pragma vp_order last%EOL%%EOL%uniform vec2 oe_LineDrawable_limits;%EOL%flat out int oe_LineDrawable_draw;%EOL%%EOL%// change in view vertex over the course of the shader pipeline%EOL%vec4 oe_LineDrawable_viewDelta;%EOL%%EOL%void oe_LineDrawable_VS_VIEW(inout vec4 vertexView)%EOL%{%EOL%    oe_LineDrawable_draw = 1;%EOL%    int first = int(oe_LineDrawable_limits[0]);%EOL%    int last = int(oe_LineDrawable_limits[1]);%EOL%    if (first >= 0)%EOL%    {%EOL%        if (gl_VertexID < first || (last > 0 && gl_VertexID > last))%EOL%        {%EOL%            oe_LineDrawable_draw = 0;%EOL%        }%EOL%    }%EOL%%EOL%    // record the change in the view vertex so that we can apply the same%EOL%    // delta to the prev and next vectors.%EOL%    vec4 originalView = gl_ModelViewMatrix * gl_Vertex;%EOL%    oe_LineDrawable_viewDelta = vertexView - originalView;%EOL%}%EOL%%EOL%%EOL%%EOL%[break]%EOL%%EOL%#version $GLSL_VERSION_STR%EOL%#pragma vp_name GPU Lines Screen Projected Clip%EOL%#pragma vp_entryPoint oe_LineDrawable_VS_CLIP%EOL%#pragma vp_location vertex_clip%EOL%#pragma import_defines(OE_LINE_SMOOTH)%EOL%%EOL%// Set by the InstallViewportUniform callback%EOL%uniform vec2 oe_ViewportSize;%EOL%%EOL%// Set by GLUtils methods%EOL%uniform float oe_GL_LineWidth;%EOL%uniform int oe_GL_LineStipplePattern;%EOL%%EOL%// Input attributes for adjacent points%EOL%in vec3 oe_LineDrawable_prev;%EOL%in vec3 oe_LineDrawable_next;%EOL%%EOL%flat out int oe_LineDrawable_draw;%EOL%flat out vec2 oe_LineDrawable_rv;%EOL%%EOL%// Change in main vertex (calculated in oe_LineDrawable_VS_VIEW)%EOL%vec4 oe_LineDrawable_viewDelta;%EOL%%EOL%#ifdef OE_LINE_SMOOTH%EOL%out float oe_LineDrawable_lateral;%EOL%#else%EOL%float oe_LineDrawable_lateral;%EOL%#endif%EOL%%EOL%void oe_LineDrawable_VS_CLIP(inout vec4 currClip)%EOL%{%EOL%    if (oe_LineDrawable_draw == 0)%EOL%        return;%EOL%%EOL%    // compute the prev and next points in clip space.%EOL%    // we apply the %QUOTE%view detla%QUOTE% to account for any other shaders that %EOL%    // might have altered the main vertex up to this point.%EOL%    vec4 prevView = gl_ModelViewMatrix * vec4(oe_LineDrawable_prev, 1.0);%EOL%    prevView += oe_LineDrawable_viewDelta;%EOL%    vec4 prevClip = gl_ProjectionMatrix * prevView;%EOL%%EOL%    vec4 nextView = gl_ModelViewMatrix * vec4(oe_LineDrawable_next, 1.0);%EOL%    nextView += oe_LineDrawable_viewDelta;%EOL%    vec4 nextClip = gl_ProjectionMatrix * nextView;%EOL%%EOL%    // transform into pixel space%EOL%    vec2 currPixel = ((currClip.xy/currClip.w)+1.0) * 0.5*oe_ViewportSize;%EOL%    vec2 prevPixel = ((prevClip.xy/prevClip.w)+1.0) * 0.5*oe_ViewportSize;%EOL%    vec2 nextPixel = ((nextClip.xy/nextClip.w)+1.0) * 0.5*oe_ViewportSize;%EOL%%EOL%#ifdef OE_LINE_SMOOTH%EOL%    float thickness = floor(oe_GL_LineWidth + 1.0); //1.5);%EOL%#else%EOL%    float thickness = max(0.5, floor(oe_GL_LineWidth));%EOL%#endif%EOL%%EOL%    float len = thickness;%EOL%%EOL%    int code = (gl_VertexID+2) & 3; // gl_VertexID % 4%EOL%    bool isStart = code <= 1;%EOL%    bool isRight = code==0 || code==2;%EOL%%EOL%    oe_LineDrawable_lateral = isRight? -1.0 : 1.0;%EOL%%EOL%    vec2 dir = vec2(0.0);%EOL%%EOL%    // We will use this to calculate stippling data:%EOL%    vec2 stippleDir;%EOL%%EOL%    // The following vertex comparisons must be done in model %EOL%    // space because the equivalency gets mashed after projection.%EOL%%EOL%    // starting point uses (next - current)%EOL%    if (gl_Vertex.xyz == oe_LineDrawable_prev)%EOL%    {%EOL%        dir = normalize(nextPixel - currPixel);%EOL%        stippleDir = dir;%EOL%    }%EOL%    %EOL%    // ending point uses (current - previous)%EOL%    else if (gl_Vertex.xyz == oe_LineDrawable_next)%EOL%    {%EOL%        dir = normalize(currPixel - prevPixel);%EOL%        stippleDir = dir;%EOL%    }%EOL%%EOL%    else%EOL%    {%EOL%        vec2 dirIn  = normalize(currPixel - prevPixel);%EOL%        vec2 dirOut = normalize(nextPixel - currPixel);%EOL%%EOL%        if (dot(dirIn,dirOut) < -0.999999)%EOL%        {%EOL%            dir = isStart? dirOut : dirIn;%EOL%        }%EOL%        else%EOL%        {%EOL%            vec2 tangent = normalize(dirIn+dirOut);%EOL%            vec2 perp = vec2(-dirIn.y, dirIn.x);%EOL%            vec2 miter = vec2(-tangent.y, tangent.x);%EOL%            dir = tangent;%EOL%            len = thickness / dot(miter, perp);%EOL%%EOL%            // limit the length of a mitered corner, to prevent unsightly spikes%EOL%            const float limit = 2.0;%EOL%            if (len > thickness*limit)%EOL%            {%EOL%                len = thickness;%EOL%                dir = isStart? dirOut : dirIn;%EOL%            }%EOL%        }%EOL%%EOL%        stippleDir = dirOut;%EOL%    }%EOL%%EOL%    // calculate the extrusion vector in pixels%EOL%    // note: seems like it should be len/2, BUT remember we are in [-w..w] space%EOL%    vec2 extrudePixel = vec2(-dir.y, dir.x) * len;%EOL%%EOL%    // and convert to unit space:%EOL%    vec2 extrudeUnit = extrudePixel / oe_ViewportSize;%EOL%%EOL%    // and from that make a clip-coord offset vector%EOL%    vec2 offset = extrudeUnit * oe_LineDrawable_lateral * currClip.w;%EOL%    currClip.xy += offset;%EOL%%EOL%    if (oe_GL_LineStipplePattern != 0xffff)%EOL%    {%EOL%        // Line creation is done. Now, calculate a rotation angle%EOL%        // for use by out fragment shader to do GPU stippling. %EOL%        // This %QUOTE%rotates%QUOTE% the fragment coordinate onto the X axis so that%EOL%        // we can apply stippling along the direction of the line.%EOL%        // Note: this depends on the GLSL %QUOTE%provoking vertex%QUOTE% being at the %EOL%        // beginning of the line segment!%EOL%%EOL%        // flip the vector so stippling always proceedes from left to right%EOL%        // regardless of the direction of the segment%EOL%        stippleDir = normalize(stippleDir.x < 0.0 ? -stippleDir : stippleDir);%EOL%%EOL%        // calculate the rotation angle that will project the%EOL%        // fragment coord onto the X-axis for stipple pattern sampling.%EOL%        float way = sign(cross(vec3(1, 0, 0), vec3(stippleDir, 0)).z);%EOL%        float angle = acos(dot(vec2(1, 0), stippleDir)) * way;%EOL%%EOL%        // quantize the rotation angle to mitigate precision problems%EOL%        // when connecting segments with slightly different vectors%EOL%        const float pi = 3.14159265359;%EOL%        const float q = pi/8.0;%EOL%        angle = floor(angle/q) * q;%EOL%%EOL%        // send it to the fragment shader.%EOL%        oe_LineDrawable_rv = vec2(cos(angle), sin(angle));%EOL%    }%EOL%}%EOL%%EOL%%EOL%[break]%EOL%%EOL%#version $GLSL_VERSION_STR%EOL%%EOL%#pragma vp_name GPU Lines Screen Projected FS%EOL%#pragma vp_entryPoint oe_LineDrawable_Stippler_FS%EOL%#pragma vp_location fragment_coloring%EOL%#pragma import_defines(OE_LINE_SMOOTH)%EOL%%EOL%uniform int oe_GL_LineStippleFactor;%EOL%uniform int oe_GL_LineStipplePattern;%EOL%%EOL%flat in vec2 oe_LineDrawable_rv;%EOL%flat in int oe_LineDrawable_draw;%EOL%%EOL%#ifdef OE_LINE_SMOOTH%EOL%in float oe_LineDrawable_lateral;%EOL%#endif%EOL%%EOL%void oe_LineDrawable_Stippler_FS(inout vec4 color)%EOL%{%EOL%    if (oe_LineDrawable_draw == 0)%EOL%        discard;%EOL%%EOL%    if (oe_GL_LineStipplePattern != 0xffff)%EOL%    {%EOL%        // coordinate of the fragment, shifted to 0:%EOL%        vec2 coord = (gl_FragCoord.xy - 0.5);%EOL%%EOL%        // rotate the frag coord onto the X-axis so we can sample the %EOL%        // stipple pattern:%EOL%        vec2 coordProj =%EOL%            mat2(oe_LineDrawable_rv.x, -oe_LineDrawable_rv.y,%EOL%                 oe_LineDrawable_rv.y,  oe_LineDrawable_rv.x)%EOL%            * coord;%EOL%%EOL%        // sample the stippling pattern (16-bits repeating)%EOL%        int ci = int(mod(coordProj.x, 16.0 * float(oe_GL_LineStippleFactor))) / oe_GL_LineStippleFactor;%EOL%        int pattern16 = 0xffff & (oe_GL_LineStipplePattern & (1 << ci));%EOL%        if (pattern16 == 0)%EOL%            discard; %EOL%%EOL%        // uncomment to debug stipple direction vectors%EOL%        //color.b = 0;%EOL%        //color.r = oe_LineDrawable_rv.x;%EOL%        //color.g = oe_LineDrawable_rv.y;%EOL%    }%EOL%%EOL%#ifdef OE_LINE_SMOOTH%EOL%    // anti-aliasing%EOL%    float L = abs(oe_LineDrawable_lateral);%EOL%    color.a = color.a * smoothstep(0.0, 1.0, 1.0-(L*L));%EOL%#endif%EOL%}%EOL%%EOL%";    

        // PointDrawable
        PointDrawable = "PointDrawable.glsl";
        _sources[PointDrawable] = "#version $GLSL_VERSION_STR%EOL%#pragma vp_name PointDrawable%EOL%#pragma vp_entryPoint oe_PointDrawable_VS_VIEW%EOL%#pragma vp_location vertex_view%EOL%#pragma vp_order last%EOL%%EOL%uniform float oe_GL_PointSize;%EOL%%EOL%void oe_PointDrawable_VS_VIEW(inout vec4 vertexView)%EOL%{%EOL%    gl_PointSize = oe_GL_PointSize;%EOL%}%EOL%%EOL%[break]%EOL%%EOL%#version $GLSL_VERSION_STR%EOL%#pragma vp_name PointDrawable FS%EOL%#pragma vp_entryPoint oe_PointDrawable_FS%EOL%#pragma vp_location fragment_coloring%EOL%#pragma import_defines(OE_POINT_SMOOTH)%EOL%%EOL%void oe_PointDrawable_FS(inout vec4 color)%EOL%{%EOL%#ifdef OE_POINT_SMOOTH%EOL%    vec2 c = 2.0*gl_PointCoord-1.0;%EOL%    float r = dot(c, c);%EOL%    float d = 0.0;%EOL%  #ifdef GL_OES_standard_derivatives%EOL%    d = fwidth(r);%EOL%  #endif%EOL%    color.a = 1.0 - smoothstep(1.0-d, 1.0+d, r);%EOL%    if (color.a < 0.1)%EOL%        discard;%EOL%#endif%EOL%}%EOL%%EOL%";          

        // PhongLightingEffect
        PhongLightingVertex = "PhongLighting.vert.glsl";
        _sources[PhongLightingVertex] = "#version $GLSL_VERSION_STR%EOL%$GLSL_DEFAULT_PRECISION_FLOAT%EOL%%EOL%#pragma vp_name       Phong Lighting Vertex Stage%EOL%#pragma vp_entryPoint oe_phong_vertex%EOL%#pragma vp_location   vertex_view%EOL%%EOL%#pragma import_defines(OE_LIGHTING)%EOL%%EOL%%EOL%out vec3 oe_phong_vertexView3;%EOL%%EOL%void oe_phong_vertex(inout vec4 VertexVIEW)%EOL%{%EOL%#ifndef OE_LIGHTING%EOL%    return;%EOL%#endif%EOL%%EOL%    oe_phong_vertexView3 = VertexVIEW.xyz / VertexVIEW.w;%EOL%}%EOL%%EOL%";
        
        PhongLightingFragment = "PhongLighting.frag.glsl";
        _sources[PhongLightingFragment] = "#version $GLSL_VERSION_STR%EOL%$GLSL_DEFAULT_PRECISION_FLOAT%EOL%%EOL%#pragma vp_name       Phong Lighting Vertex Stage%EOL%#pragma vp_entryPoint oe_phong_fragment%EOL%#pragma vp_location   fragment_lighting%EOL%%EOL%#pragma import_defines(OE_LIGHTING)%EOL%#pragma import_defines(OE_NUM_LIGHTS)%EOL%%EOL%#ifdef OE_LIGHTING%EOL%%EOL%in vec3 oe_phong_vertexView3; %EOL%%EOL%// stage global%EOL%vec3 vp_Normal;%EOL%%EOL%// Parameters of each light:%EOL%struct osg_LightSourceParameters %EOL%{   %EOL%   vec4 ambient;%EOL%   vec4 diffuse;%EOL%   vec4 specular;%EOL%   vec4 position;%EOL%   vec3 spotDirection;%EOL%   float spotExponent;%EOL%   float spotCutoff;%EOL%   float spotCosCutoff;%EOL%   float constantAttenuation;%EOL%   float linearAttenuation;%EOL%   float quadraticAttenuation;%EOL%%EOL%   bool enabled;%EOL%};  %EOL%uniform osg_LightSourceParameters osg_LightSource[OE_NUM_LIGHTS];%EOL%%EOL%// Surface material:%EOL%struct osg_MaterialParameters  %EOL%{   %EOL%   vec4 emission;    // Ecm   %EOL%   vec4 ambient;     // Acm   %EOL%   vec4 diffuse;     // Dcm   %EOL%   vec4 specular;    // Scm   %EOL%   float shininess;  // Srm  %EOL%};  %EOL%uniform osg_MaterialParameters osg_FrontMaterial; %EOL%%EOL%%EOL%void oe_phong_fragment(inout vec4 color) %EOL%{%EOL%    // See:%EOL%    // https://en.wikipedia.org/wiki/Phong_reflection_model%EOL%    // https://www.opengl.org/sdk/docs/tutorials/ClockworkCoders/lighting.php%EOL%    // https://en.wikibooks.org/wiki/GLSL_Programming/GLUT/Multiple_Lights%EOL%%EOL%    vec3 N = normalize(vp_Normal);%EOL%%EOL%    float shine = clamp(osg_FrontMaterial.shininess, 1.0, 128.0); %EOL%%EOL%    // Accumulate the lighting, starting with material emission. We are currently%EOL%    // omitting the ambient term for now since we are not using LightModel ambience.%EOL%    vec3 totalLighting =%EOL%        osg_FrontMaterial.emission.rgb;%EOL%        // + osg_FrontMaterial.ambient.rgb * osg_LightModel.ambient.rgb;%EOL%    %EOL%    int numLights = OE_NUM_LIGHTS; //min(osg_NumLights, MAX_LIGHTS);%EOL%%EOL%    for (int i=0; i<numLights; ++i)%EOL%    {%EOL%        const float attenuation = 1.0;%EOL%%EOL%        if (osg_LightSource[i].enabled)%EOL%        {%EOL%            float attenuation = 1.0;%EOL%            vec3 L; // vertex-to-light-source vector.%EOL%%EOL%            // directional light:%EOL%            if (osg_LightSource[i].position.w == 0.0)%EOL%            {%EOL%                L = normalize(osg_LightSource[i].position.xyz);%EOL%            }%EOL%%EOL%            // point or spot light:%EOL%            else%EOL%            {%EOL%                // calculate VL, the vertex-to-light vector:%EOL%                vec4 V = vec4(oe_phong_vertexView3, 1.0) * osg_LightSource[i].position.w;%EOL%                vec4 VL4 = osg_LightSource[i].position - V;%EOL%                L = normalize(VL4.xyz);%EOL%%EOL%                // calculate attenuation:%EOL%                float distance = length(VL4);%EOL%                attenuation = 1.0 / (%EOL%                    osg_LightSource[i].constantAttenuation +%EOL%                    osg_LightSource[i].linearAttenuation * distance +%EOL%                    osg_LightSource[i].quadraticAttenuation * distance * distance);%EOL%%EOL%                // for a spot light, the attenuation help form the cone:%EOL%                if (osg_LightSource[i].spotCutoff <= 90.0)%EOL%                {%EOL%                    vec3 D = normalize(osg_LightSource[i].spotDirection);%EOL%                    float clampedCos = max(0.0, dot(-L,D));%EOL%                    attenuation = clampedCos < osg_LightSource[i].spotCosCutoff ?%EOL%                        0.0 :%EOL%                        attenuation * pow(clampedCos, osg_LightSource[i].spotExponent);%EOL%                }%EOL%            }%EOL%%EOL%            vec3 ambientReflection =%EOL%                attenuation%EOL%                * osg_FrontMaterial.ambient.rgb%EOL%                * osg_LightSource[i].ambient.rgb;%EOL%%EOL%            float NdotL = max(dot(N,L), 0.0); %EOL%%EOL%            vec3 diffuseReflection =%EOL%                attenuation%EOL%                * osg_LightSource[i].diffuse.rgb * osg_FrontMaterial.diffuse.rgb%EOL%                * NdotL;%EOL%                %EOL%            vec3 specularReflection = vec3(0.0);%EOL%            if (NdotL > 0.0)%EOL%            {%EOL%                vec3 H = reflect(-L,N); %EOL%                float HdotN = max(dot(H,N), 0.0); %EOL%%EOL%                specularReflection =%EOL%                    attenuation%EOL%                    * osg_LightSource[i].specular.rgb%EOL%                    * osg_FrontMaterial.specular.rgb%EOL%                    * pow(HdotN, shine);%EOL%            }%EOL%%EOL%            totalLighting += ambientReflection + diffuseReflection + specularReflection;%EOL%        }%EOL%    }%EOL%    %EOL%    color.rgb *= totalLighting;%EOL%}%EOL%%EOL%#else%EOL%%EOL%// nop%EOL%void oe_phong_fragment(inout vec4 color) { }%EOL%%EOL%#endif%EOL%";

		// Text
		TextVertex = "Text.vert.glsl";
		_sources[TextVertex] = "#version $GLSL_VERSION_STR%EOL%%EOL%out vec2 oe_Text_texCoord;%EOL%%EOL%#pragma vp_entryPoint oe_Text_VS%EOL%#pragma vp_location   vertex_view%EOL%%EOL%void oe_Text_VS(inout vec4 position)%EOL%{%EOL%    oe_Text_texCoord = gl_MultiTexCoord0.xy;%EOL%}%EOL%%EOL%";

		TextFragment = "Text.frag.glsl";
		_sources[TextFragment] = "#version $GLSL_VERSION_STR%EOL%%EOL%#ifdef GL_ES%EOL%    #extension GL_OES_standard_derivatives : enable%EOL%    #ifndef GL_OES_standard_derivatives%EOL%        #undef SIGNED_DISTANCE_FIELD%EOL%    #endif%EOL%#endif%EOL%%EOL%#if !defined(GL_ES)%EOL%    #if __VERSION__>=400%EOL%        #define osg_TextureQueryLOD textureQueryLod%EOL%    #else%EOL%        #extension GL_ARB_texture_query_lod : enable%EOL%        #ifdef GL_ARB_texture_query_lod%EOL%            #define osg_TextureQueryLOD textureQueryLOD%EOL%        #endif%EOL%    #endif%EOL%#endif%EOL%%EOL%#pragma vp_entryPoint oe_Text_FS%EOL%#pragma vp_location   fragment_coloring%EOL%%EOL%#pragma import_defines(BACKDROP_COLOR, SHADOW, OUTLINE)%EOL%#pragma import_defines(SIGNED_DISTANCE_FIELD, TEXTURE_DIMENSION, GLYPH_DIMENSION)%EOL%#pragma import_defines(OSGTEXT_GLYPH_ALPHA_FORMAT_IS_RED)%EOL%%EOL%#if __VERSION__>=130%EOL%    #define TEXTURE texture%EOL%    #define TEXTURELOD textureLod%EOL%#else%EOL%    #define TEXTURE texture2D%EOL%    #define TEXTURELOD texture2DLod%EOL%#endif%EOL%%EOL%%EOL%//#if !defined(GL_ES) && __VERSION__>=130%EOL%#ifdef OSGTEXT_GLYPH_ALPHA_FORMAT_IS_RED%EOL%    #define ALPHA r%EOL%    #define SDF g%EOL%#else%EOL%    #define ALPHA a%EOL%    #define SDF r%EOL%#endif%EOL%%EOL%%EOL%uniform sampler2D glyphTexture;%EOL%%EOL%in vec2 oe_Text_texCoord;%EOL%vec4 vertexColor;%EOL%%EOL%#ifndef TEXTURE_DIMENSION%EOL%    #define TEXTURE_DIMENSION float(1024.0)%EOL%#endif%EOL%%EOL%#ifndef GLYPH_DIMENSION%EOL%    #define GLYPH_DIMENSION float(32.0)%EOL%#endif%EOL%%EOL%#ifdef SIGNED_DISTANCE_FIELD%EOL%%EOL%float distanceFromEdge(vec2 tc)%EOL%{%EOL%    float center_alpha = TEXTURELOD(glyphTexture, tc, 0.0).SDF;%EOL%    if (center_alpha==0.0) return -1.0;%EOL%%EOL%    //float distance_scale = (1.0/4.0)*1.41;%EOL%    float distance_scale = (1.0/6.0)*1.41;%EOL%    //float distance_scale = (1.0/8.0)*1.41;%EOL%%EOL%    return (center_alpha-0.5)*distance_scale;%EOL%}%EOL%%EOL%vec4 distanceFieldColorSample(float edge_distance, float blend_width, float  blend_half_width)%EOL%{%EOL%#ifdef OUTLINE%EOL%    float outline_width = OUTLINE*0.5;%EOL%    if (edge_distance>blend_half_width)%EOL%    {%EOL%        return vertexColor;%EOL%    }%EOL%    else if (edge_distance>-blend_half_width)%EOL%    {%EOL%        return mix(vertexColor, vec4(BACKDROP_COLOR.rgb, BACKDROP_COLOR.a*vertexColor.a), smoothstep(0.0, 1.0, (blend_half_width-edge_distance)/(blend_width)));%EOL%    }%EOL%    else if (edge_distance>(blend_half_width-outline_width))%EOL%    {%EOL%        return vec4(BACKDROP_COLOR.rgb, BACKDROP_COLOR.a*vertexColor.a);%EOL%    }%EOL%    else if (edge_distance>-(outline_width+blend_half_width))%EOL%    {%EOL%        return vec4(BACKDROP_COLOR.rgb, vertexColor.a * ((blend_half_width+outline_width+edge_distance)/blend_width));%EOL%    }%EOL%    else%EOL%    {%EOL%        return vec4(0.0, 0.0, 0.0, 0.0);%EOL%    }%EOL%#else%EOL%    if (edge_distance>blend_half_width)%EOL%    {%EOL%        return vertexColor;%EOL%    }%EOL%    else if (edge_distance>-blend_half_width)%EOL%    {%EOL%        return vec4(vertexColor.rgb, vertexColor.a * smoothstep(1.0, 0.0, (blend_half_width-edge_distance)/(blend_width)));%EOL%    }%EOL%    else%EOL%    {%EOL%        return vec4(0.0, 0.0, 0.0, 0.0);%EOL%    }%EOL%#endif%EOL%}%EOL%%EOL%vec4 textColor(vec2 src_texCoord)%EOL%{%EOL%    float sample_distance_scale = 0.75;%EOL%    vec2 dx = dFdx(src_texCoord)*sample_distance_scale;%EOL%    vec2 dy = dFdy(src_texCoord)*sample_distance_scale;%EOL%%EOL%%EOL%    float distance_across_pixel = length(dx+dy)*(TEXTURE_DIMENSION/GLYPH_DIMENSION);%EOL%%EOL%    // compute the appropriate number of samples required to avoid aliasing.%EOL%    int maxNumSamplesAcrossSide = 4;%EOL%%EOL%    int numSamplesX = int(TEXTURE_DIMENSION * length(dx));%EOL%    int numSamplesY = int(TEXTURE_DIMENSION * length(dy));%EOL%    if (numSamplesX<2) numSamplesX = 2;%EOL%    if (numSamplesY<2) numSamplesY = 2;%EOL%    if (numSamplesX>maxNumSamplesAcrossSide) numSamplesX = maxNumSamplesAcrossSide;%EOL%    if (numSamplesY>maxNumSamplesAcrossSide) numSamplesY = maxNumSamplesAcrossSide;%EOL%%EOL%%EOL%    vec2 delta_tx = dx/float(numSamplesX-1);%EOL%    vec2 delta_ty = dy/float(numSamplesY-1);%EOL%%EOL%    float numSamples = float(numSamplesX)*float(numSamplesY);%EOL%    float scale = 1.0/numSamples;%EOL%    vec4 total_color = vec4(0.0,0.0,0.0,0.0);%EOL%%EOL%    float blend_width = 1.5*distance_across_pixel/numSamples;%EOL%    float blend_half_width = blend_width*0.5;%EOL%%EOL%    // check whether fragment is wholly within or outwith glyph body+outline%EOL%    float cd = distanceFromEdge(src_texCoord); // central distance (distance from center to edge)%EOL%    if (cd-blend_half_width>distance_across_pixel) return vertexColor; // pixel fully within glyph body%EOL%%EOL%    #ifdef OUTLINE%EOL%    float outline_width = OUTLINE*0.5;%EOL%    if ((-cd-outline_width-blend_half_width)>distance_across_pixel) return vec4(0.0, 0.0, 0.0, 0.0); // pixel fully outside outline+glyph body%EOL%    #else%EOL%    if (-cd-blend_half_width>distance_across_pixel) return vec4(0.0, 0.0, 0.0, 0.0); // pixel fully outside glyph body%EOL%    #endif%EOL%%EOL%%EOL%    // use multi-sampling to provide high quality antialised fragments%EOL%    vec2 origin = src_texCoord - dx*0.5 - dy*0.5;%EOL%    for(;numSamplesY>0; --numSamplesY)%EOL%    {%EOL%        vec2 pos = origin;%EOL%        int numX = numSamplesX;%EOL%        for(;numX>0; --numX)%EOL%        {%EOL%            vec4 c = distanceFieldColorSample(distanceFromEdge(pos), blend_width, blend_half_width);%EOL%            total_color = total_color + c * c.a;%EOL%            pos += delta_tx;%EOL%        }%EOL%        origin += delta_ty;%EOL%    }%EOL%%EOL%    total_color.rgb /= total_color.a;%EOL%    total_color.a *= scale;%EOL%%EOL%    return total_color;%EOL%}%EOL%%EOL%#else%EOL%%EOL%vec4 textColor(vec2 src_texCoord)%EOL%{%EOL%%EOL%#ifdef OUTLINE%EOL%%EOL%    float alpha = TEXTURE(glyphTexture, src_texCoord).ALPHA;%EOL%    float delta_tc = 1.6*OUTLINE*GLYPH_DIMENSION/TEXTURE_DIMENSION;%EOL%%EOL%    float outline_alpha = alpha;%EOL%    vec2 origin = src_texCoord-vec2(delta_tc*0.5, delta_tc*0.5);%EOL%%EOL%    float numSamples = 3.0;%EOL%    delta_tc = delta_tc/(numSamples-1.0);%EOL%%EOL%    float background_alpha = 1.0;%EOL%%EOL%    for(float i=0.0; i<numSamples; ++i)%EOL%    {%EOL%        for(float j=0.0; j<numSamples; ++j)%EOL%        {%EOL%            float local_alpha = TEXTURE(glyphTexture, origin + vec2(i*delta_tc, j*delta_tc)).ALPHA;%EOL%            outline_alpha = max(outline_alpha, local_alpha);%EOL%            background_alpha = background_alpha * (1.0-local_alpha);%EOL%        }%EOL%    }%EOL%%EOL%    #ifdef osg_TextureQueryLOD%EOL%        float mipmapLevel = osg_TextureQueryLOD(glyphTexture, src_texCoord).x;%EOL%        if (mipmapLevel<1.0)%EOL%        {%EOL%            outline_alpha = mix(1.0-background_alpha, outline_alpha, mipmapLevel/1.0);%EOL%        }%EOL%    #endif%EOL%%EOL%    if (outline_alpha<alpha) outline_alpha = alpha;%EOL%    if (outline_alpha>1.0) outline_alpha = 1.0;%EOL%%EOL%    if (outline_alpha==0.0) return vec4(0.0, 0.0, 0.0, 0.0); // outside glyph and outline%EOL%%EOL%    vec4 color = mix(BACKDROP_COLOR, vertexColor, smoothstep(0.0, 1.0, alpha));%EOL%    color.a = vertexColor.a * smoothstep(0.0, 1.0, outline_alpha);%EOL%%EOL%    return color;%EOL%%EOL%#else%EOL%%EOL%    float alpha = TEXTURE(glyphTexture, src_texCoord).ALPHA;%EOL%    if (alpha==0.0) vec4(0.0, 0.0, 0.0, 0.0);%EOL%    return vec4(vertexColor.rgb, vertexColor.a * alpha);%EOL%%EOL%#endif%EOL%}%EOL%%EOL%#endif%EOL%%EOL%void oe_Text_FS(inout vec4 color)%EOL%{%EOL%    float originalAlpha = color.a;%EOL%    vertexColor = vec4(color.rgb, 1.0);%EOL%%EOL%    if (oe_Text_texCoord.x<0.0 && oe_Text_texCoord.y<0.0)%EOL%    {%EOL%        return;%EOL%    }%EOL%%EOL%#ifdef SHADOW%EOL%    float scale = -1.0*GLYPH_DIMENSION/TEXTURE_DIMENSION;%EOL%    vec2 delta_tc = SHADOW*scale;%EOL%    vec4 shadow_color = textColor(oe_Text_texCoord+delta_tc);%EOL%    shadow_color.rgb = BACKDROP_COLOR.rgb;%EOL%%EOL%    vec4 glyph_color = textColor(oe_Text_texCoord);%EOL%%EOL%    // lower the alpha_power value the greater the saturation, no need to be so aggressive with SDF than GREYSCALE%EOL%    #if SIGNED_DISTANCE_FIELD%EOL%        float alpha_power = 0.6;%EOL%    #else%EOL%        float alpha_power = 0.5;%EOL%    #endif%EOL%%EOL%    // over saturate the alpha values to make sure the font and it's shadow are clear%EOL%    shadow_color.a = pow(shadow_color.a, alpha_power);%EOL%    glyph_color.a = pow(glyph_color.a, alpha_power);%EOL%    vec4 clr = mix(shadow_color, glyph_color, glyph_color.a);%EOL%#else%EOL%    vec4 clr = textColor(oe_Text_texCoord);%EOL%#endif%EOL%%EOL%    if (clr.a==0.0) discard;%EOL%%EOL%    color = clr;%EOL%    color.a *= originalAlpha;%EOL%}%EOL%%EOL%";

        TextLegacy = "Text_legacy.glsl";
        _sources[TextLegacy] = "#version $GLSL_VERSION_STR%EOL%#pragma vp_entryPoint oe_Text_VS%EOL%#pragma vp_location   vertex_view%EOL%%EOL%out vec2 oe_Text_texcoord;%EOL%%EOL%void oe_Text_VS(inout vec4 position)%EOL%{%EOL%    oe_Text_texcoord = gl_MultiTexCoord0.xy;%EOL%%EOL%#if !defined(GL_ES) && __VERSION__<140%EOL%    gl_ClipVertex = gl_ModelViewMatrix * gl_Vertex;%EOL%#endif%EOL%}%EOL%%EOL%[break]%EOL%%EOL%#version $GLSL_VERSION_STR%EOL%#pragma vp_entryPoint oe_Text_FS%EOL%#pragma vp_location   fragment_coloring%EOL%%EOL%uniform sampler2D glyphTexture;%EOL%in vec2 oe_Text_texcoord;%EOL%%EOL%void oe_Text_FS(inout vec4 color)%EOL%{%EOL%    color.a *= texture(glyphTexture, oe_Text_texcoord).a;%EOL%}%EOL%%EOL%";
    }
};
