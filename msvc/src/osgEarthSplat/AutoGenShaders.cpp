// CMake will compile this file into AutoGenShaders.c""

#include <osgEarthSplat/SplatShaders>

//#define MULTILINE(...) #__VA_ARGS__

using namespace osgEarth::Splat;

SplattingShaders::SplattingShaders()
{
    Types = "Splat.types.glsl";
    _sources[Types] = "// begin: Splat.types.glsl%EOL%%EOL%// Environment structure passed around locally.%EOL%struct oe_SplatEnv {%EOL%    float lod;%EOL%    float range;%EOL%    float elevation;%EOL%    float slope;%EOL%    vec4 noise;%EOL%};%EOL%%EOL%// Rendering parameters for splat texture and noise-based detail texture.%EOL%struct oe_SplatRenderInfo {%EOL%    float primaryIndex;%EOL%    float detailIndex;%EOL%    float brightness;%EOL%    float contrast;%EOL%    float threshold;%EOL%    float minSlope;%EOL%};%EOL%%EOL%// end: Splat.types.glsl%EOL%";

    Noise = "Splat.Noise.glsl";
    _sources[Noise] = "#version $GLSL_VERSION_STR%EOL%$GLSL_DEFAULT_PRECISION_FLOAT%EOL%%EOL%//%EOL%// Description : Array and textureless GLSL 2D/3D/4D simplex %EOL%//               noise functions.%EOL%//      Author : Ian McEwan, Ashima Arts.%EOL%//  Maintainer : ijm%EOL%//     Lastmod : 20110822 (ijm)%EOL%//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.%EOL%//               Distributed under the MIT License. See LICENSE file.%EOL%//               https://github.com/ashima/webgl-noise%EOL%// %EOL%%EOL%vec4 oe_noise_mod289(vec4 x) {%EOL%  return x - floor(x * (1.0 / 289.0)) * 289.0; }%EOL%%EOL%float oe_noise_mod289(float x) {%EOL%  return x - floor(x * (1.0 / 289.0)) * 289.0; }%EOL%%EOL%vec4 oe_noise_permute(vec4 x) {%EOL%     return oe_noise_mod289(((x*34.0)+1.0)*x);%EOL%}%EOL%%EOL%float oe_noise_permute(float x) {%EOL%     return oe_noise_mod289(((x*34.0)+1.0)*x);%EOL%}%EOL%%EOL%vec4 oe_noise_taylorInvSqrt(vec4 r)%EOL%{%EOL%  return 1.79284291400159 - 0.85373472095314 * r;%EOL%}%EOL%%EOL%float oe_noise_taylorInvSqrt(float r)%EOL%{%EOL%  return 1.79284291400159 - 0.85373472095314 * r;%EOL%}%EOL%%EOL%vec4 oe_noise_grad4(float j, vec4 ip)%EOL%  {%EOL%  const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);%EOL%  vec4 p,s;%EOL%%EOL%  p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;%EOL%  p.w = 1.5 - dot(abs(p.xyz), ones.xyz);%EOL%  s = vec4(lessThan(p, vec4(0.0)));%EOL%  p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www; %EOL%%EOL%  return p;%EOL%  }%EOL%						%EOL%// (sqrt(5) - 1)/4 = F4, used once below%EOL%#define oe_noise_F4 0.309016994374947451%EOL%%EOL%float oe_noise_snoise(vec4 v)%EOL%  {%EOL%  const vec4  C = vec4( 0.138196601125011,  // (5 - sqrt(5))/20  G4%EOL%                        0.276393202250021,  // 2 * G4%EOL%                        0.414589803375032,  // 3 * G4%EOL%                       -0.447213595499958); // -1 + 4 * G4%EOL%%EOL%// First corner%EOL%  vec4 i  = floor(v + dot(v, vec4(oe_noise_F4)) );%EOL%  vec4 x0 = v -   i + dot(i, C.xxxx);%EOL%%EOL%// Other corners%EOL%%EOL%// Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)%EOL%  vec4 i0;%EOL%  vec3 isX = step( x0.yzw, x0.xxx );%EOL%  vec3 isYZ = step( x0.zww, x0.yyz );%EOL%//  i0.x = dot( isX, vec3( 1.0 ) );%EOL%  i0.x = isX.x + isX.y + isX.z;%EOL%  i0.yzw = 1.0 - isX;%EOL%//  i0.y += dot( isYZ.xy, vec2( 1.0 ) );%EOL%  i0.y += isYZ.x + isYZ.y;%EOL%  i0.zw += 1.0 - isYZ.xy;%EOL%  i0.z += isYZ.z;%EOL%  i0.w += 1.0 - isYZ.z;%EOL%%EOL%  // i0 now contains the unique values 0,1,2,3 in each channel%EOL%  vec4 i3 = clamp( i0, 0.0, 1.0 );%EOL%  vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );%EOL%  vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );%EOL%%EOL%  //  x0 = x0 - 0.0 + 0.0 * C.xxxx%EOL%  //  x1 = x0 - i1  + 1.0 * C.xxxx%EOL%  //  x2 = x0 - i2  + 2.0 * C.xxxx%EOL%  //  x3 = x0 - i3  + 3.0 * C.xxxx%EOL%  //  x4 = x0 - 1.0 + 4.0 * C.xxxx%EOL%  vec4 x1 = x0 - i1 + C.xxxx;%EOL%  vec4 x2 = x0 - i2 + C.yyyy;%EOL%  vec4 x3 = x0 - i3 + C.zzzz;%EOL%  vec4 x4 = x0 + C.wwww;%EOL%%EOL%// Permutations%EOL%  i = oe_noise_mod289(i); %EOL%  float j0 = oe_noise_permute( oe_noise_permute( oe_noise_permute( oe_noise_permute(i.w) + i.z) + i.y) + i.x);%EOL%  vec4 j1 = oe_noise_permute( oe_noise_permute( oe_noise_permute( oe_noise_permute (%EOL%             i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))%EOL%           + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))%EOL%           + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))%EOL%           + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));%EOL%%EOL%// Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope%EOL%// 7*7*6 = 294, which is close to the ring size 17*17 = 289.%EOL%  vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;%EOL%%EOL%  vec4 p0 = oe_noise_grad4(j0,   ip);%EOL%  vec4 p1 = oe_noise_grad4(j1.x, ip);%EOL%  vec4 p2 = oe_noise_grad4(j1.y, ip);%EOL%  vec4 p3 = oe_noise_grad4(j1.z, ip);%EOL%  vec4 p4 = oe_noise_grad4(j1.w, ip);%EOL%%EOL%// Normalise gradients%EOL%  vec4 norm = oe_noise_taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));%EOL%  p0 *= norm.x;%EOL%  p1 *= norm.y;%EOL%  p2 *= norm.z;%EOL%  p3 *= norm.w;%EOL%  p4 *= oe_noise_taylorInvSqrt(dot(p4,p4));%EOL%%EOL%// Mix contributions from the five corners%EOL%  vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);%EOL%  vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);%EOL%  m0 = m0 * m0;%EOL%  m1 = m1 * m1;%EOL%  return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))%EOL%               + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;%EOL%}%EOL%%EOL%// Generates a tiled fractal simplex noise value and clamps the values to [0..1].%EOL%float oe_noise_fractal4D(in vec2 seed, in float frequency, in float persistence, in float lacunarity, in int octaves)%EOL%{%EOL%    const float TwoPI = 6.283185;%EOL%	float f = frequency;%EOL%	float amp = 1.0;%EOL%	float maxAmp = 0.0;%EOL%	float n = 0.0;%EOL%    %EOL%    vec4 seed4D;%EOL%    seed4D.xy = cos(seed*TwoPI)/TwoPI;%EOL%    seed4D.zw = sin(seed*TwoPI)/TwoPI;%EOL%%EOL%	for(int i=0; i<octaves; ++i)%EOL%	{%EOL%		n += oe_noise_snoise(seed4D*f) * amp;%EOL%		maxAmp += amp;%EOL%		amp *= persistence;%EOL%		f *= lacunarity;%EOL%	}%EOL%	//return n / maxAmp;%EOL%    const float low = 0.0;%EOL%    const float high = 1.0;%EOL%%EOL%    n /= maxAmp;%EOL%    n = n * (high-low)/2.0 + (high+low)/2.0;%EOL%    return clamp(n, 0.0, 1.0);%EOL%}%EOL%%EOL%";

    VertModel = "Splat.vert.model.glsl";
    _sources[VertModel] = "#version $GLSL_VERSION_STR%EOL%$GLSL_DEFAULT_PRECISION_FLOAT%EOL%%EOL%#pragma vp_entryPoint oe_splat_vertex_model%EOL%#pragma vp_location   vertex_model%EOL%#pragma vp_order      0.5%EOL%#pragma import_defines(OE_TERRAIN_RENDER_NORMAL_MAP)%EOL%%EOL%// Transmit the approximate terrain slope if we're not rendering normal maps%EOL%// in the terrain engine.%EOL%#ifndef OE_TERRAIN_RENDER_NORMAL_MAP%EOL%vec3 vp_Normal; // stage global%EOL%out float oe_splat_slope;%EOL%%EOL%void oe_splat_vertex_model(inout vec4 VertexMODEL)%EOL%{%EOL%    // calculate slope from the Z component of the current normal%EOL%    // since the terrain is in LTP space. This is only used when normal maps%EOL%    // are not available, which is hopefully never :/%EOL%    oe_splat_slope = 1.0-vp_Normal.z;%EOL%}%EOL%%EOL%#else%EOL%%EOL%void oe_splat_vertex_model(inout vec4 VertexMODEL)%EOL%{%EOL%    //nop%EOL%}%EOL%%EOL%#endif%EOL%%EOL%";

    VertView = "Splat.vert.view.glsl";
    _sources[VertView] = "#version $GLSL_VERSION_STR%EOL%$GLSL_DEFAULT_PRECISION_FLOAT%EOL%%EOL%#pragma vp_entryPoint oe_splat_vertex_view%EOL%#pragma vp_location   vertex_view%EOL%#pragma vp_order      0.5%EOL%%EOL%#pragma include Splat.types.glsl%EOL%%EOL%#pragma import_defines(OE_SPLAT_COVERAGE_TEXMAT)%EOL%%EOL%out vec4 oe_layer_tilec;%EOL%out float oe_splat_range;%EOL%out vec2 oe_splat_covtc;%EOL%%EOL%uniform sampler2D oe_splat_coverageTex;%EOL%flat out float oe_splat_coverageTexSize;%EOL%%EOL%uniform mat4 OE_SPLAT_COVERAGE_TEXMAT;   // assigned at runtime%EOL%%EOL%%EOL%void oe_splat_vertex_view(inout vec4 VertexVIEW)%EOL%{%EOL%    // range from camera to vertex%EOL%    oe_splat_range = -VertexVIEW.z;%EOL%%EOL%    // calculate the coverage sampling coordinates. The texture matrix accounts%EOL%    // for any super-sampling that might be in effect for the current LOD.%EOL%    oe_splat_covtc = (OE_SPLAT_COVERAGE_TEXMAT * oe_layer_tilec).st;%EOL%%EOL%    // Precalculate the size of the coverage texture. This is faster than%EOL%    // calling textureSize per pixel in the fragment shader.%EOL%    oe_splat_coverageTexSize = textureSize(oe_splat_coverageTex, 0).x;%EOL%}%EOL%%EOL%";

    Frag = "Splat.frag.glsl";
    _sources[Frag] = "#version $GLSL_VERSION_STR%EOL%$GLSL_DEFAULT_PRECISION_FLOAT%EOL%%EOL%#if(__VERSION__ < 400)%EOL%#extension GL_ARB_gpu_shader5 : enable      // textureGather%EOL%#endif%EOL%%EOL%#pragma vp_entryPoint oe_splat_complex%EOL%#pragma vp_location   fragment_coloring%EOL%%EOL%// include files%EOL%#pragma include Splat.types.glsl%EOL%%EOL%// statset defines%EOL%#pragma import_defines(OE_SPLAT_NOISE_SAMPLER)%EOL%#pragma import_defines(OE_SPLAT_EDIT_MODE)%EOL%#pragma import_defines(OE_SPLAT_GPU_NOISE)%EOL%#pragma import_defines(OE_TERRAIN_RENDER_NORMAL_MAP)%EOL%#pragma import_defines(OE_TERRAIN_BLEND_IMAGERY)%EOL%%EOL%// Uncomment this to use textureGather() in the oe_splat_bilinear function,%EOL%// but read the comments there first!%EOL%//#define USE_TEXTURE_GATHER%EOL%%EOL%// from: Splat.util.glsl%EOL%void oe_splat_getLodBlend(in float range, out float lod0, out float rangeOuter, out float rangeInner, out float clampedRange);%EOL%%EOL%// from terrain SDK:%EOL%vec2 oe_terrain_scaleCoordsToRefLOD(in vec2 tc, in float refLOD);%EOL%%EOL%// from the terrain engine:%EOL%in vec4 oe_layer_tilec;                     // unit tile coords%EOL%%EOL%// from the vertex shader:%EOL%in vec2 oe_splat_covtc;                     // coverage texture coords%EOL%in float oe_splat_range;                    // distance from camera to vertex%EOL%flat in float oe_splat_coverageTexSize;     // size of coverage texture%EOL%%EOL%in float oe_layer_opacity;%EOL%%EOL%// from SplatLayerFactory:%EOL%uniform sampler2D oe_splat_coverageTex;%EOL%uniform sampler2DArray oe_splatTex;%EOL%uniform int oe_splat_scaleOffsetInt;%EOL%%EOL%uniform float oe_splat_detailRange;%EOL%uniform float oe_splat_noiseScale;%EOL%%EOL%#ifdef OE_SPLAT_EDIT_MODE%EOL%uniform float oe_splat_brightness;%EOL%uniform float oe_splat_contrast;%EOL%uniform float oe_splat_threshold;%EOL%uniform float oe_splat_minSlope;%EOL%#endif%EOL%%EOL%// lookup table containing the coverage value => texture index mappings%EOL%uniform samplerBuffer oe_splat_coverageLUT;%EOL%%EOL%uniform int oe_layer_order;%EOL%%EOL%//............................................................................%EOL%// Get the slope of the terrain%EOL%%EOL%#ifdef OE_TERRAIN_RENDER_NORMAL_MAP%EOL%// import SDK%EOL%vec4 oe_terrain_getNormalAndCurvature(in vec2);%EOL%%EOL%// normal map version:%EOL%in vec2 oe_normalMapCoords;%EOL%%EOL%float oe_splat_getSlope()%EOL%{%EOL%    vec4 encodedNormal = oe_terrain_getNormalAndCurvature( oe_normalMapCoords );%EOL%    vec3 normalTangent = normalize(encodedNormal.xyz*2.0-1.0);%EOL%    return clamp((1.0-normalTangent.z)/0.8, 0.0, 1.0);%EOL%}%EOL%%EOL%#else // !OE_TERRAIN_RENDER_NORMAL_MAP%EOL%%EOL%// non- normal map version:%EOL%in float oe_splat_slope;%EOL%%EOL%float oe_splat_getSlope()%EOL%{%EOL%    return oe_splat_slope;%EOL%}%EOL%%EOL%#endif // OE_TERRAIN_RENDER_NORMAL_MAP%EOL%%EOL%%EOL%//............................................................................%EOL%// reads the encoded splatting render information for a coverage value.%EOL%// this data was encoded in Surface::createLUTBUffer().%EOL%%EOL%void oe_splat_getRenderInfo(in float value, in oe_SplatEnv env, out oe_SplatRenderInfo ri)%EOL%{%EOL%    const int num_lods = 26;%EOL%%EOL%    int lutIndex = int(value)*num_lods + int(env.lod);%EOL%%EOL%    // fetch the splatting parameters:%EOL%    vec4 t = texelFetch(oe_splat_coverageLUT, lutIndex);%EOL%%EOL%    ri.primaryIndex = t[0];%EOL%    ri.detailIndex  = t[1];%EOL%%EOL%    // brightness and contrast are packed into one float:%EOL%    ri.brightness   = trunc(t[2])/100.0;%EOL%    ri.contrast     = fract(t[2])*10.0;%EOL%%EOL%    // threshold and slope are packed into one float:%EOL%    ri.threshold    = trunc(t[3])/100.0;%EOL%    ri.minSlope     = fract(t[3])*10.0;%EOL%}%EOL%%EOL%%EOL%//............................................................................%EOL%// Sample a texel from the splatting texture catalog%EOL%%EOL%vec4 oe_splat_getTexel(in float index, in vec2 tc)%EOL%{%EOL%    //return texture(oe_splatTex, vec3(tc, index));%EOL%    return index >= 0.0 ? texture(oe_splatTex, vec3(tc, index)) : vec4(1,0,0,0);%EOL%}%EOL%%EOL%%EOL%//............................................................................%EOL%// Samples a detail texel using its render info parameters.%EOL%// Returns the weighting factor in the alpha channel.%EOL%%EOL%vec4 oe_splat_getDetailTexel(in oe_SplatRenderInfo ri, in vec2 tc, in oe_SplatEnv env)%EOL%{%EOL%    float hasDetail = clamp(ri.detailIndex+1.0, 0.0, 1.0);%EOL%%EOL%#ifdef OE_SPLAT_EDIT_MODE%EOL%    float brightness = oe_splat_brightness;%EOL%    float contrast = oe_splat_contrast;%EOL%    float threshold = oe_splat_threshold;%EOL%    float minSlope = oe_splat_minSlope;%EOL%#else%EOL%    float brightness = ri.brightness;%EOL%    float contrast = ri.contrast;%EOL%    float threshold = ri.threshold;%EOL%    float minSlope = ri.minSlope;%EOL%#endif%EOL%%EOL%    // start with the noise value%EOL%    float n = env.noise.x;%EOL%	%EOL%    // apply slope limiter, then reclamp and threshold:%EOL%    float s;%EOL%    if ( env.slope >= minSlope )%EOL%        s = 1.0;%EOL%    else if ( env.slope < 0.1*minSlope )%EOL%        s = 0.0;%EOL%    else%EOL%        s = (env.slope-0.1*minSlope)/(minSlope-0.1*minSlope);%EOL%%EOL%    brightness *= s;%EOL%%EOL%    // apply brightness and contrast, then reclamp%EOL%    n = clamp(((n-0.5)*contrast + 0.5) * brightness, 0.0, 1.0);%EOL%    %EOL%    // apply final threshold:%EOL%	n = n < threshold ? 0.0 : n;%EOL%%EOL%    // sample the texel and return it.%EOL%    vec4 result = oe_splat_getTexel(ri.detailIndex, tc);%EOL%    return vec4(result.rgb, hasDetail*n);%EOL%}%EOL%%EOL%//............................................................................%EOL%// Generates a texel using nearest-neighbor coverage sampling.%EOL%%EOL%vec4 oe_splat_nearest(in vec2 splat_tc, inout oe_SplatEnv env)%EOL%{%EOL%    float coverageValue = texture(oe_splat_coverageTex, oe_splat_covtc).r;%EOL%    oe_SplatRenderInfo ri;%EOL%    oe_splat_getRenderInfo(coverageValue, env, ri);%EOL%    vec4 primary = oe_splat_getTexel(ri.primaryIndex, splat_tc);%EOL%    float detailToggle = ri.detailIndex >= 0 ? 1.0 : 0.0;%EOL%    vec4 detail  = oe_splat_getDetailTexel(ri, splat_tc, env) * detailToggle;    %EOL%    return vec4( mix(primary.rgb, detail.rgb, detail.a), primary.a );%EOL%}%EOL%%EOL%//............................................................................%EOL%// Generates a texel using bilinear filtering on the coverage data.%EOL%%EOL%vec4 oe_splat_bilinear(in vec2 splat_tc, inout oe_SplatEnv env)%EOL%{%EOL%    vec4 texel = vec4(0,0,0,1);%EOL%%EOL%    float size = oe_splat_coverageTexSize;%EOL%%EOL%#ifdef USE_TEXTURE_GATHER%EOL%%EOL%    // A wee bit faster, but causes a rendering anomaly -- lines of %EOL%    // incorrectly splatted textures appear at higher resolutions.%EOL%    // Problem may be in the bilinear weight calculation but not sure%EOL%%EOL%    vec4 value = textureGather(oe_splat_coverageTex, oe_splat_covtc, 0);%EOL%    float value_sw = value.w;%EOL%    float value_se = value.z;%EOL%    float value_ne = value.y;%EOL%    float value_nw = value.x;%EOL%%EOL%#else%EOL%        //TODO: coverage warping is slow due to the noise function. Consider removing/reworking.%EOL%    vec2 tc = oe_splat_covtc;%EOL%%EOL%    float pixelWidth = 1.0/size;%EOL%    float halfPixelWidth = pixelWidth * 0.5;%EOL%    float pixelWidth2 = pixelWidth * pixelWidth;%EOL%%EOL%     // Find the four quantized coverage coordinates that form a box around the actual%EOL%    // coverage coordinates, where each quantized coord is at the center of a coverage texel.%EOL%    vec2 rem = mod(tc, pixelWidth);%EOL%    vec2 sw;%EOL%    sw.x = tc.x - rem.x + (rem.x >= halfPixelWidth ? halfPixelWidth : -halfPixelWidth);%EOL%    sw.y = tc.y - rem.y + (rem.y >= halfPixelWidth ? halfPixelWidth : -halfPixelWidth); %EOL%    vec2 ne = sw + pixelWidth;%EOL%    vec2 nw = vec2(sw.x, ne.y);%EOL%    vec2 se = vec2(ne.x, sw.y);%EOL%%EOL%    // Calculate the weighting for each corner.%EOL%    vec2 dsw = tc-sw;%EOL%    vec2 dse = tc-se;%EOL%    vec2 dne = tc-ne;%EOL%    vec2 dnw = tc-nw;%EOL%%EOL%    float sw_weight = max(pixelWidth2-dot(dsw,dsw),0.0);%EOL%    float se_weight = max(pixelWidth2-dot(dse,dse),0.0);%EOL%    float ne_weight = max(pixelWidth2-dot(dne,dne),0.0);%EOL%    float nw_weight = max(pixelWidth2-dot(dnw,dnw),0.0);%EOL%%EOL%     // normalize the weights so they total 1.0%EOL%    float invTotalWeight = 1.0/(sw_weight+se_weight+ne_weight+nw_weight);%EOL%    sw_weight *= invTotalWeight;%EOL%    se_weight *= invTotalWeight;%EOL%    ne_weight *= invTotalWeight;%EOL%    nw_weight *= invTotalWeight;%EOL%%EOL%     // Sample coverage values using quantized corner coords:%EOL%    float value_sw = texture(oe_splat_coverageTex, clamp(sw, 0.0, 1.0)).r;%EOL%    float value_se = texture(oe_splat_coverageTex, clamp(se, 0.0, 1.0)).r;%EOL%    float value_ne = texture(oe_splat_coverageTex, clamp(ne, 0.0, 1.0)).r;%EOL%    float value_nw = texture(oe_splat_coverageTex, clamp(nw, 0.0, 1.0)).r;%EOL%#endif%EOL%%EOL%%EOL%    // Build the render info data for each corner:%EOL%    oe_SplatRenderInfo ri_sw; oe_splat_getRenderInfo(value_sw, env, ri_sw);%EOL%    oe_SplatRenderInfo ri_se; oe_splat_getRenderInfo(value_se, env, ri_se);%EOL%    oe_SplatRenderInfo ri_ne; oe_splat_getRenderInfo(value_ne, env, ri_ne);%EOL%    oe_SplatRenderInfo ri_nw; oe_splat_getRenderInfo(value_nw, env, ri_nw);%EOL%%EOL%    // Primary splat:%EOL%    vec4 sw_primary = oe_splat_getTexel(ri_sw.primaryIndex, splat_tc);%EOL%    vec4 se_primary = oe_splat_getTexel(ri_se.primaryIndex, splat_tc);%EOL%    vec4 ne_primary = oe_splat_getTexel(ri_ne.primaryIndex, splat_tc);%EOL%    vec4 nw_primary = oe_splat_getTexel(ri_nw.primaryIndex, splat_tc);%EOL%%EOL%    // Detail splat - weighting is in the alpha channel%EOL%    // TODO: Pointless to have a detail range? -gw%EOL%    // TODO: If noise is a texture, just try to single-sample it instead%EOL%    float detailToggle = env.range < oe_splat_detailRange ? 1.0 : 0.0;%EOL%    vec4 sw_detail = detailToggle * oe_splat_getDetailTexel(ri_sw, splat_tc, env);%EOL%    vec4 se_detail = detailToggle * oe_splat_getDetailTexel(ri_se, splat_tc, env);%EOL%    vec4 ne_detail = detailToggle * oe_splat_getDetailTexel(ri_ne, splat_tc, env);%EOL%    vec4 nw_detail = detailToggle * oe_splat_getDetailTexel(ri_nw, splat_tc, env); %EOL%%EOL%    vec4 nw_mix = vec4(mix(nw_primary.rgb, nw_detail.rgb, nw_detail.a), nw_primary.a);%EOL%    vec4 ne_mix = vec4(mix(ne_primary.rgb, ne_detail.rgb, ne_detail.a), ne_primary.a);%EOL%    vec4 sw_mix = vec4(mix(sw_primary.rgb, sw_detail.rgb, sw_detail.a), sw_primary.a);%EOL%    vec4 se_mix = vec4(mix(se_primary.rgb, se_detail.rgb, se_detail.a), se_primary.a);%EOL%%EOL%    vec2 weight = fract( oe_splat_covtc*size - 0.5);%EOL%%EOL%    vec4 temp0 = mix(nw_mix, ne_mix, weight.x);%EOL%    vec4 temp1 = mix(sw_mix, se_mix, weight.x);%EOL%%EOL%    texel = mix(temp1, temp0, weight.y);%EOL%%EOL%    return texel;%EOL%}%EOL%%EOL%//............................................................................%EOL%%EOL%#ifdef OE_SPLAT_GPU_NOISE%EOL%%EOL%uniform float oe_splat_freq;%EOL%uniform float oe_splat_pers;%EOL%uniform float oe_splat_lac;%EOL%uniform float oe_splat_octaves;%EOL%%EOL%// see: Splat.Noise.glsl%EOL%float oe_noise_fractal4D(in vec2 seed, in float frequency, in float persistence, in float lacunarity, in int octaves);%EOL%%EOL%vec4 oe_splat_getNoise(in vec2 tc)%EOL%{%EOL%    return vec4(oe_noise_fractal4D(tc, oe_splat_freq, oe_splat_pers, oe_splat_lac, int(oe_splat_octaves)));%EOL%}%EOL%%EOL%#else // !SPLAT_GPU_NOISE%EOL%%EOL%#ifdef OE_SPLAT_NOISE_SAMPLER%EOL%uniform sampler2D OE_SPLAT_NOISE_SAMPLER;%EOL%vec4 oe_splat_getNoise(in vec2 tc)%EOL%{%EOL%    return texture(OE_SPLAT_NOISE_SAMPLER, tc.st);%EOL%}%EOL%#else%EOL%vec4 oe_splat_getNoise(in vec2 tc)%EOL%{%EOL%    return vec4(0.0);%EOL%}%EOL%#endif%EOL%%EOL%#endif // SPLAT_GPU_NOISE%EOL%%EOL%%EOL%%EOL%//............................................................................%EOL%// Simplified entry point with does no filtering or range blending. (much faster.)%EOL%%EOL%void oe_splat_simple(inout vec4 color)%EOL%{%EOL%    float noiseLOD = floor(oe_splat_noiseScale);%EOL%    vec2 noiseCoords = oe_terrain_scaleCoordsToRefLOD(oe_layer_tilec.st, noiseLOD);%EOL%%EOL%    oe_SplatEnv env;%EOL%    env.range = oe_splat_range;%EOL%    env.slope = oe_splat_getSlope();%EOL%    env.noise = oe_splat_getNoise(noiseCoords);%EOL%    env.elevation = 0.0;%EOL%    %EOL%    float lod0;%EOL%    float rangeOuter, rangeInner;%EOL%    oe_splat_getLodBlend(oe_splat_range, lod0, rangeOuter, rangeInner, env.range);%EOL%    vec2 tc = oe_terrain_scaleCoordsToRefLOD(oe_layer_tilec.st, lod0 + float(oe_splat_scaleOffsetInt));%EOL%%EOL%    color = oe_splat_bilinear(tc, env);%EOL%    //color = oe_splat_nearest(tc, env);%EOL%%EOL%    color.a *= oe_layer_opacity;%EOL%}%EOL%%EOL%//............................................................................%EOL%// Main entry point for fragment shader.%EOL%%EOL%void oe_splat_complex(inout vec4 color)%EOL%{%EOL%    // Noise coords.%EOL%    float noiseLOD = floor(oe_splat_noiseScale);%EOL%    vec2 noiseCoords = oe_terrain_scaleCoordsToRefLOD(oe_layer_tilec.st, noiseLOD); //TODO: move to VS for slight speedup%EOL%%EOL%    oe_SplatEnv env;%EOL%    env.range = oe_splat_range;%EOL%    env.slope = oe_splat_getSlope();%EOL%    env.noise = oe_splat_getNoise(noiseCoords);%EOL%    env.elevation = 0.0;%EOL%%EOL%    // quantize the scale offset so we take the hit in the FS%EOL%    float scaleOffset = float(oe_splat_scaleOffsetInt);%EOL%        %EOL%    // Calculate the 2 LODs we need to blend. We have to do this in the FS because %EOL%    // it's quite possible for a single triangle to span more than 2 LODs.%EOL%    float lod0, lod1;%EOL%    float rangeOuter, rangeInner;%EOL%    oe_splat_getLodBlend(oe_splat_range, lod0, rangeOuter, rangeInner, env.range);%EOL%    %EOL%    // Sample the two LODs:%EOL%    vec2 tc0 = oe_terrain_scaleCoordsToRefLOD(oe_layer_tilec.st, lod0 + scaleOffset);%EOL%    env.lod = lod0;%EOL%    vec4 texel0 = oe_splat_bilinear(tc0, env);%EOL%    %EOL%    vec2 tc1 = oe_terrain_scaleCoordsToRefLOD(oe_layer_tilec.st, lod0 + 1.0 + scaleOffset);%EOL%    env.lod = lod0+1.0;%EOL%    vec4 texel1 = oe_splat_bilinear(tc1, env);%EOL%%EOL%    // recalcluate blending ratio%EOL%    float lodBlend = clamp((rangeOuter - env.range) / (rangeOuter - rangeInner), 0, 1);%EOL%       %EOL%    // Blend the two samples based on LOD factor:%EOL%    vec4 texel = mix(texel0, texel1, lodBlend);%EOL%%EOL%%EOL%    // incorporate the layer's opacity:%EOL%    texel.a *= oe_layer_opacity;%EOL%%EOL%#ifdef OE_TERRAIN_BLEND_IMAGERY%EOL%    // If this is a first image layer, blend with the incoming terrain color.%EOL%    // Otherwise, apply directly and let GL blending do the rest.%EOL%    if (oe_layer_order == 0)%EOL%    {%EOL%        color.rgb = texel.rgb*texel.a + color.rgb*(1.0-texel.a);%EOL%    }%EOL%    else%EOL%    {%EOL%        color = texel;%EOL%    }%EOL%#else%EOL%    // No blending? The output is just the texel value.%EOL%    color = texel;%EOL%#endif // OE_TERRAIN_BLEND_IMAGERY%EOL%}%EOL%%EOL%";

    Util = "Splat.util.glsl";
    _sources[Util] = "#version $GLSL_VERSION_STR%EOL%$GLSL_DEFAULT_PRECISION_FLOAT%EOL%%EOL%#pragma vp_location fragment_coloring%EOL%%EOL%// Number of LOD range. Do not increase this past 25; doing so will result in precision errors%EOL%// and rendering artifacts when the camera is very close to the ground.%EOL%#define LOD_COUNT 26%EOL%%EOL%const float oe_SplatRanges[26] = float[](%EOL%       100000000.0, // 0%EOL%        75000000.0, // 1%EOL%        50000000.0, // 2%EOL%        10000000.0, // 3%EOL%         7500000.0, // 4%EOL%         5000000.0, // 5%EOL%         2500000.0, // 6%EOL%         1000000.0, // 7%EOL%          500000.0, // 8%EOL%          225000.0, // 9%EOL%          150000.0, // 10%EOL%           80000.0, // 11%EOL%           30000.0, // 12%EOL%           14000.0, // 13%EOL%            4000.0, // 14%EOL%            2500.0, // 15%EOL%            1000.0, // 16%EOL%             500.0, // 17%EOL%             250.0, // 18%EOL%             125.0, // 19%EOL%              50.0, // 20%EOL%              25.0, // 21%EOL%              12.0, // 22%EOL%               6.0, // 23%EOL%               3.0, // 24%EOL%               1.0  // 25%EOL%    );%EOL%%EOL%/**%EOL% * Given a camera distance, return the two LODs it falls between and%EOL% * the blend factor [0..1] between then.%EOL% * in  range   = camera distace to fragment%EOL% * in  baseLOD = LOD at which texture scale is 1.0%EOL% * out LOD0    = near LOD%EOL% * out LOD1    = far LOD%EOL% * out blend   = Blend factor between LOD0 and LOD1 [0..1]%EOL% */%EOL%void%EOL%oe_splat_getLodBlend(in float range, out float out_LOD0, out float out_rangeOuter, out float out_rangeInner, out float out_clampedRange)%EOL%{%EOL%    out_clampedRange = clamp(range, oe_SplatRanges[LOD_COUNT-1], oe_SplatRanges[0]);%EOL%%EOL%    out_LOD0 = 0;%EOL%%EOL%    for(int i=0; i<LOD_COUNT-1; ++i)%EOL%    {%EOL%        if ( out_clampedRange < oe_SplatRanges[i] && out_clampedRange >= oe_SplatRanges[i+1] )%EOL%        {%EOL%            out_LOD0 = float(i); //   + baseLOD;%EOL%            break;%EOL%        }%EOL%    }%EOL%%EOL%    out_rangeOuter = oe_SplatRanges[int(out_LOD0)];%EOL%    out_rangeInner = oe_SplatRanges[int(out_LOD0)+1];%EOL%}%EOL%%EOL%";
}


GroundCoverShaders::GroundCoverShaders()
{
    GroundCover_TCS = "GroundCover.TCS.glsl";
    _sources[GroundCover_TCS] = "#version 400%EOL%%EOL%/**%EOL% * TCS that assigns a patch grid density.%EOL% */%EOL% %EOL%#pragma vp_name       GroundCover tessellation control shader%EOL%#pragma vp_entryPoint oe_GroundCover_configureTess%EOL%#pragma vp_location   tess_control%EOL%%EOL%layout(vertices=3) out;%EOL%%EOL%uniform float oe_GroundCover_density;%EOL%%EOL%// per-vertex tile coordinates%EOL%vec4 oe_layer_tilec;%EOL%%EOL%#ifdef OE_GROUNDCOVER_COVERAGE_PRECHECK%EOL%// SDK function to sample the coverage data%EOL%int oe_GroundCover_getBiomeIndex(in vec4);%EOL%%EOL%// SDK function to load per-vertex data%EOL%void VP_LoadVertex(in int);%EOL%#endif%EOL%%EOL%// MAIN ENTRY POINT                %EOL%void oe_GroundCover_configureTess()%EOL%{%EOL%	if (gl_InvocationID == 0)%EOL%	{%EOL%        float d = oe_GroundCover_density;%EOL%%EOL%#ifdef OE_GROUNDCOVER_COVERAGE_PRECHECK%EOL%        // Samples the three corner points to see whether the triangle%EOL%        // is likely to contain a groundcover biome. This is not perfect%EOL%        // since it only samples the corner points, and the performance%EOL%        // benefits are questionable. -gw%EOL%        VP_LoadVertex(0);%EOL%        if ( oe_GroundCover_getBiomeIndex(oe_layer_tilec) >= 0 ) {%EOL%            d = oe_GroundCover_density;%EOL%        }%EOL%        else {%EOL%            VP_LoadVertex(1);%EOL%            if ( oe_GroundCover_getBiomeIndex(oe_layer_tilec) >= 0 ) {%EOL%                d = oe_GroundCover_density;%EOL%                VP_LoadVertex(0);%EOL%            }%EOL%            else {%EOL%                VP_LoadVertex(2);%EOL%                if ( oe_GroundCover_getBiomeIndex(oe_layer_tilec) >= 0 ) {%EOL%                    d = oe_GroundCover_density;%EOL%                    VP_LoadVertex(0);%EOL%                }%EOL%            }%EOL%        }%EOL%#endif%EOL%%EOL%        gl_TessLevelOuter[0] = d;%EOL%        gl_TessLevelOuter[1] = d;%EOL%        gl_TessLevelOuter[2] = d;%EOL%        gl_TessLevelInner[0] = d+1;%EOL%	}%EOL%}%EOL%%EOL%";

    GroundCover_TES = "GroundCover.TES.glsl";
    _sources[GroundCover_TES] = "#version 410%EOL%%EOL%#pragma vp_name       GroundCover TES Shader%EOL%#pragma vp_entryPoint oe_GroundCover_tessellate%EOL%#pragma vp_location   tess_eval%EOL%%EOL%// osgEarth terrain is always CCW winding%EOL%layout(triangles, equal_spacing, ccw) in;%EOL%%EOL%// Internal helpers:%EOL%void VP_Interpolate3();%EOL%void VP_EmitVertex();%EOL%%EOL%float VP_Interpolate3(float a, float b, float c) %EOL%{%EOL%    return dot(gl_TessCoord.xyz, vec3(a,b,c));%EOL%}%EOL%%EOL%vec2 VP_Interpolate3(vec2 a, vec2 b, vec2 c) %EOL%{%EOL%    return vec2(dot(gl_TessCoord.xyz, vec3(a.x,b.x,c.x)),%EOL%	dot(gl_TessCoord.xyz, vec3(a.y,b.y,c.y)));%EOL%}%EOL%%EOL%vec3 VP_Interpolate3(vec3 a, vec3 b, vec3 c) %EOL%{%EOL%    return vec3(dot(gl_TessCoord.xyz, vec3(a.x,b.x,c.x)),%EOL%	dot(gl_TessCoord.xyz, vec3(a.y,b.y,c.y)),%EOL%	dot(gl_TessCoord.xyz, vec3(a.z,b.z,c.z)));%EOL%}%EOL%%EOL%vec4 VP_Interpolate3(vec4 a, vec4 b, vec4 c) %EOL%{%EOL%    return vec4(dot(gl_TessCoord.xyz, vec3(a.x,b.x,c.x)),%EOL%				dot(gl_TessCoord.xyz, vec3(a.y,b.y,c.y)),%EOL%				dot(gl_TessCoord.xyz, vec3(a.z,b.z,c.z)),%EOL%				dot(gl_TessCoord.xyz, vec3(a.w,b.w,c.w)));%EOL%}%EOL%%EOL%                %EOL%vec3 vp_Normal;%EOL%%EOL%// simplest possible pass-though:%EOL%void oe_GroundCover_tessellate()%EOL%{%EOL%    VP_Interpolate3();%EOL%    // Must re-normalize the normal vector since interpolation was linear?%EOL%	//vp_Normal = normalize(vp_Normal);%EOL%    VP_EmitVertex();%EOL%}%EOL%%EOL%";

    GroundCover_GS = "GroundCover.GS.glsl";
    _sources[GroundCover_GS] = "#version $GLSL_VERSION_STR%EOL%$GLSL_DEFAULT_PRECISION_FLOAT%EOL%#pragma vp_name       GroundCover geometry shader%EOL%#pragma vp_entryPoint oe_GroundCover_geom%EOL%#pragma vp_location   geometry%EOL%%EOL%#pragma import_defines(OE_IS_SHADOW_CAMERA)%EOL%#pragma import_defines(OE_GROUNDCOVER_MASK_SAMPLER)%EOL%#pragma import_defines(OE_GROUNDCOVER_MASK_MATRIX)%EOL%#pragma import_defines(OE_GROUNDCOVER_SHOW_TESSELLATION)%EOL%                %EOL%layout(triangles) in;        // triangles from the TileDrawable%EOL%%EOL%#ifdef OE_GROUNDCOVER_SHOW_TESSELLATION%EOL%layout(line_strip, max_vertices=4) out;%EOL%#else%EOL%layout(triangle_strip, max_vertices=4) out;       // four verts per billboard%EOL%#endif%EOL%                %EOL%// VP helper functions:%EOL%void VP_LoadVertex(in int);%EOL%void VP_EmitViewVertex();%EOL%%EOL%uniform float osg_FrameTime;            // Frame time (seconds) used for wind animation%EOL%                %EOL%uniform float oe_GroundCover_width;           // width of each billboard%EOL%uniform float oe_GroundCover_height;          // height of each billboard%EOL%uniform float oe_GroundCover_ao;              // fake ambient occlusion of ground verts (0=full)%EOL%%EOL%uniform float oe_GroundCover_fill;            // percentage of points that make it through, based on noise function%EOL%uniform float oe_GroundCover_windFactor;      // wind blowing the foliage%EOL%uniform float oe_GroundCover_maxDistance;     // distance at which flora disappears%EOL%%EOL%uniform float oe_GroundCover_contrast;%EOL%uniform float oe_GroundCover_brightness;%EOL%%EOL%uniform sampler2D oe_tile_elevationTex;%EOL%uniform mat4      oe_tile_elevationTexMatrix;%EOL%uniform float     oe_tile_elevationSize;%EOL%%EOL%// Noise texture:%EOL%uniform sampler2D oe_GroundCover_noiseTex;%EOL%%EOL%// different noise texture channels:%EOL%#define NOISE_SMOOTH   0%EOL%#define NOISE_RANDOM   1%EOL%#define NOISE_RANDOM_2 2%EOL%#define NOISE_CLUMPY   3%EOL%%EOL%// Input tile coordinates [0..1]%EOL%in vec4 oe_layer_tilec;%EOL%%EOL%// Output grass texture coordinates to the fragment shader%EOL%out vec2 oe_GroundCover_texCoord;%EOL%%EOL%// Input from the TCS that %EOL%//flat in int oe_GroundCover_biomeIndex;%EOL%%EOL%// Output that selects the land cover texture from the texture array (non interpolated)%EOL%flat out float oe_GroundCover_arrayIndex;%EOL%%EOL%struct oe_GroundCover_Biome {%EOL%    int firstBillboardIndex;%EOL%    int numBillboards;%EOL%    float density;%EOL%    float fill;%EOL%    vec2 maxWidthHeight;%EOL%};%EOL%void oe_GroundCover_getBiome(in int biomeIndex, out oe_GroundCover_Biome biome);%EOL%%EOL%struct oe_GroundCover_Billboard {%EOL%    int arrayIndex;%EOL%    float width;%EOL%    float height;%EOL%};%EOL%void oe_GroundCover_getBillboard(in int billboardIndex, out oe_GroundCover_Billboard bb);%EOL%%EOL%%EOL%// Output colors/normals:%EOL%out vec4 vp_Color;%EOL%out vec3 vp_Normal;%EOL%%EOL%// Up vector for clamping.%EOL%in vec3 oe_UpVectorView;%EOL%%EOL%// SDK import%EOL%float oe_terrain_getElevation(in vec2);%EOL%%EOL%// Generated in code%EOL%int oe_GroundCover_getBiomeIndex(in vec4);%EOL%%EOL%#ifdef OE_GROUNDCOVER_MASK_SAMPLER%EOL%uniform sampler2D OE_GROUNDCOVER_MASK_SAMPLER;%EOL%uniform mat4 OE_GROUNDCOVER_MASK_MATRIX;%EOL%#endif%EOL%%EOL%// Sample the elevation texture and move the vertex accordingly.%EOL%void%EOL%oe_GroundCover_clamp(inout vec4 vert_view, in vec3 up, vec2 UV)%EOL%{%EOL%    float elev = oe_terrain_getElevation( UV );%EOL%    vert_view.xyz += up*elev;%EOL%}%EOL%%EOL%// Generate a pseudo-random value in the specified range:%EOL%float%EOL%oe_GroundCover_rangeRand(float minValue, float maxValue, vec2 co)%EOL%{%EOL%    float t = fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);%EOL%    return minValue + t*(maxValue-minValue);%EOL%}%EOL%%EOL%// Generate a wind-perturbation value%EOL%float%EOL%oe_GroundCover_applyWind(float time, float factor, float randOffset)%EOL%{%EOL%   return sin(time + randOffset) * factor;%EOL%}%EOL%%EOL%// Generate a pseudo-random barycentric point inside a triangle.%EOL%vec3%EOL%oe_GroundCover_getRandomBarycentricPoint(vec2 seed)%EOL%{%EOL%    vec3 b;%EOL%    b[0] = oe_GroundCover_rangeRand(0.0, 1.0, seed.xy);%EOL%    b[1] = oe_GroundCover_rangeRand(0.0, 1.0, seed.yx);%EOL%    if (b[0]+b[1] >= 1.0)%EOL%    {%EOL%        b[0] = 1.0 - b[0];%EOL%        b[1] = 1.0 - b[1];%EOL%    }%EOL%    b[2] = 1.0 - b[0] - b[1];%EOL%    return b;%EOL%}%EOL%%EOL%// MAIN ENTRY POINT  %EOL%void%EOL%oe_GroundCover_geom()%EOL%{    %EOL%    vec4 center = vec4(0,0,0,1);%EOL%    vec2 tileUV = vec2(0,0);%EOL%%EOL%#ifdef OE_GROUNDCOVER_SHOW_TESSELLATION%EOL%    for(int i=0; i < 3; ++i)%EOL%    {%EOL%        VP_LoadVertex(i);      %EOL%        gl_Position = gl_in[i].gl_Position;%EOL%        gl_Position.z += 10.0;%EOL%        gl_Position = gl_ModelViewMatrix * gl_Position;%EOL%        VP_EmitViewVertex();%EOL%    }%EOL%    VP_LoadVertex(0);    %EOL%    gl_Position = gl_in[0].gl_Position;%EOL%    gl_Position.z += 10.0;%EOL%    gl_Position = gl_ModelViewMatrix * gl_Position;%EOL%    VP_EmitViewVertex();%EOL%%EOL%    EndPrimitive();%EOL%    return;%EOL%#endif%EOL%        %EOL%    // gen a random point within the input triangle%EOL%    vec3 b = oe_GroundCover_getRandomBarycentricPoint(gl_in[0].gl_Position.xy);%EOL%    %EOL%    // Load the triangle data and compute the new position and tile coords%EOL%    // using the barycentric coordinates.%EOL%    for(int i=0; i < 3; ++i)%EOL%    {%EOL%        VP_LoadVertex(i);      %EOL%        %EOL%        center.x += b[i] * gl_in[i].gl_Position.x;%EOL%        center.y += b[i] * gl_in[i].gl_Position.y;%EOL%        center.z += b[i] * gl_in[i].gl_Position.z;%EOL%        %EOL%        tileUV.x += b[i] * oe_layer_tilec.x;%EOL%        tileUV.y += b[i] * oe_layer_tilec.y;%EOL%    }%EOL%   %EOL%    // Look up the biome at this point:%EOL%    int biomeIndex = oe_GroundCover_getBiomeIndex(vec4(tileUV,0,1));%EOL%    if ( biomeIndex < 0 )%EOL%    {%EOL%        // No biome defined; bail out without emitting any geometry.%EOL%        return;%EOL%    }%EOL%    %EOL%    // If we're using a mask texture, sample it now:%EOL%#ifdef OE_GROUNDCOVER_MASK_SAMPLER%EOL%    float mask = texture(OE_GROUNDCOVER_MASK_SAMPLER, (OE_GROUNDCOVER_MASK_MATRIX*vec4(tileUV,0,1)).st).a;%EOL%    if ( mask > 0.0 )%EOL%    {%EOL%        // Failed to pass the mask; no geometry emitted.%EOL%        return;%EOL%    }%EOL%#endif%EOL%    %EOL%    // Transform to view space.%EOL%    vec4 center_view = gl_ModelViewMatrix * center;%EOL%    vec3 up_view     = oe_UpVectorView;%EOL%    %EOL%    // Clamp the center point to the elevation.%EOL%    oe_GroundCover_clamp(center_view, up_view, tileUV);%EOL%%EOL%    // Calculate the normalized camera range:%EOL%    float nRange = clamp(-center_view.z/oe_GroundCover_maxDistance, 0.0, 1.0);%EOL%%EOL%    // Distance culling:%EOL%    if ( nRange == 1.0 )%EOL%        return;%EOL%%EOL%    // look up biome:%EOL%    oe_GroundCover_Biome biome;%EOL%    oe_GroundCover_getBiome(biomeIndex, biome);%EOL%%EOL%    // sample the noise texture.%EOL%    vec4 noise = texture(oe_GroundCover_noiseTex, tileUV);%EOL%%EOL%    // a pseudo-random scale factor to the width and height of a billboard%EOL%    float sizeScale = abs(1.0 + noise[NOISE_RANDOM_2]);%EOL%    %EOL%    // Viewpoint culling:%EOL%    // TODO: remove hard-coded max width/height and replace with a vp_define or a uniform.%EOL%    // Note: this value must account for the height variation introduced by the noise function%EOL%    // later in this shader!%EOL%    vec4 cullPoint = center_view;%EOL%    //vec2 maxWidthHeight = biome.maxWidthHeight * sizeScale;%EOL%    cullPoint.xy -= sign(cullPoint.xy) * min(biome.maxWidthHeight*sizeScale, abs(cullPoint.xy));%EOL%    cullPoint = gl_ProjectionMatrix * cullPoint;%EOL%    float absw = abs(cullPoint.w);%EOL%    if ( abs(cullPoint.x) > absw || abs(cullPoint.y) > absw )// || abs(cullPoint.z) > absw )%EOL%        return;%EOL%%EOL%    // discard instances based on noise value threshold (coverage). If it passes,%EOL%    // scale the noise value back up to [0..1]%EOL%    if ( noise[NOISE_SMOOTH] > oe_GroundCover_fill )%EOL%        return;%EOL%    else%EOL%        noise[NOISE_SMOOTH] /= oe_GroundCover_fill;%EOL%%EOL%    // select a billboard seemingly at random. Need to scale n to account for the fill limit first though.%EOL%    int billboardIndex = biome.firstBillboardIndex + int( floor(noise[NOISE_RANDOM] * float(biome.numBillboards) ) );%EOL%    billboardIndex = min(billboardIndex, biome.firstBillboardIndex + biome.numBillboards - 1);%EOL%%EOL%    oe_GroundCover_Billboard billboard;%EOL%    oe_GroundCover_getBillboard(billboardIndex, billboard);%EOL%    %EOL%    // pass the billboard's array index along to the fragment shader.%EOL%    oe_GroundCover_arrayIndex = float(billboard.arrayIndex);%EOL%    %EOL%	%EOL%    // push the falloff closer to the max distance.%EOL%    float falloff = 1.0-(nRange*nRange*nRange);%EOL%%EOL%    // billboard width, which shrinks into the distance%EOL%    float width = billboard.width * falloff * sizeScale;%EOL%    %EOL%    float height = billboard.height * falloff * sizeScale;%EOL%%EOL%    // vary the height of each instance and shrink it as it disappears into the distance.%EOL%    // TODO: consider parameterizing this so we can toggle the feature%EOL%    //height *= sizeScale;%EOL%%EOL%    // shrink land cover as it dissappears into the distance:%EOL%    //height *= falloff;%EOL%%EOL%	// compute the billboard corners in view space.%EOL%    vec4 LL, LR, UL, UR;%EOL%    %EOL%%EOL%#ifdef OE_IS_SHADOW_CAMERA%EOL%    %EOL%    vec3 tangentVector = gl_NormalMatrix * vec3(1,0,0); // vector pointing east-ish.%EOL%    vec3 halfWidthTangentVector = cross(tangentVector, up_view) * 0.5 * width;%EOL%    vec3 heightVector = up_view*height;%EOL%%EOL%    vp_Color = vec4(1,1,1,falloff);%EOL%%EOL%    for(int i=0; i<2; ++i)%EOL%    {%EOL%        LL = vec4(center_view.xyz - halfWidthTangentVector, 1.0);%EOL%        LR = vec4(center_view.xyz + halfWidthTangentVector, 1.0);%EOL%        UL = vec4(LL.xyz + heightVector, 1.0);%EOL%        UR = vec4(LR.xyz + heightVector, 1.0);%EOL%    %EOL%        // calculates normal:%EOL%        vp_Normal = normalize(cross(tangentVector, heightVector));%EOL%        %EOL%        gl_Position = LL;%EOL%        oe_GroundCover_texCoord = vec2(0,0);%EOL%        VP_EmitViewVertex();%EOL%    %EOL%        gl_Position = LR;%EOL%        oe_GroundCover_texCoord = vec2(1,0);%EOL%        VP_EmitViewVertex();    %EOL%%EOL%        gl_Position = UL;%EOL%        oe_GroundCover_texCoord = vec2(0,1);%EOL%        VP_EmitViewVertex();%EOL%%EOL%        oe_GroundCover_texCoord = vec2(1,1);%EOL%        gl_Position = UR;%EOL%        VP_EmitViewVertex();%EOL%                    %EOL%        EndPrimitive();%EOL%%EOL%        tangentVector = gl_NormalMatrix * vec3(0,1,0);%EOL%        halfWidthTangentVector = cross(tangentVector, up_view) * 0.5 * width;%EOL%    }%EOL%%EOL%#else // normal render camera - draw as a billboard:%EOL%%EOL%    vec3 tangentVector = normalize(cross(center_view.xyz, up_view));%EOL%    vec3 halfWidthTangentVector = tangentVector * 0.5 * width;%EOL%    vec3 heightVector = up_view*height;%EOL%        %EOL%    LL = vec4(center_view.xyz - halfWidthTangentVector, 1.0);%EOL%    LR = vec4(center_view.xyz + halfWidthTangentVector, 1.0);%EOL%    UL = vec4(LL.xyz + heightVector, 1.0);%EOL%    UR = vec4(LR.xyz + heightVector, 1.0);%EOL%                      %EOL%    // TODO: animate based on wind parameters.%EOL%    float nw = noise[NOISE_SMOOTH];%EOL%    float wind = width*oe_GroundCover_windFactor*nw;%EOL%    UL.x += oe_GroundCover_applyWind(osg_FrameTime*(1+nw), wind, UL.x);%EOL%    UR.x += oe_GroundCover_applyWind(osg_FrameTime*(1-nw), wind, tileUV.t);%EOL%    %EOL%    // Color variation, brightness, and contrast:%EOL%    vec3 color = vec3( noise[NOISE_RANDOM_2] );%EOL%    color = ( ((color - 0.5) * oe_GroundCover_contrast + 0.5) * oe_GroundCover_brightness);%EOL%%EOL%    vp_Color = vec4(color*oe_GroundCover_ao, falloff);%EOL%%EOL%    // calculates normals:%EOL%    vec3 faceNormalVector = normalize(cross(tangentVector, heightVector));%EOL%%EOL%    // if we are looking straight-ish down on the billboard, don't bother with it%EOL%    if (abs(dot(normalize(center_view.xyz), faceNormalVector)) < 0.01)%EOL%        return;%EOL%%EOL%    float blend = 0.25 + (noise[NOISE_RANDOM_2]*0.25);%EOL%    vec3 Lnormal = mix(-tangentVector, faceNormalVector, blend);%EOL%    vec3 Rnormal = mix( tangentVector, faceNormalVector, blend);%EOL%%EOL%    gl_Position = LL;%EOL%    oe_GroundCover_texCoord = vec2(0,0);%EOL%    vp_Normal = Lnormal;%EOL%    VP_EmitViewVertex();%EOL%    %EOL%    gl_Position = LR;%EOL%    oe_GroundCover_texCoord = vec2(1,0);%EOL%    vp_Normal = Rnormal;%EOL%    VP_EmitViewVertex();%EOL%%EOL%    vp_Color = vec4(color, falloff);      %EOL%%EOL%    gl_Position = UL;%EOL%    oe_GroundCover_texCoord = vec2(0,1);%EOL%    vp_Normal = Lnormal;%EOL%    VP_EmitViewVertex();%EOL%%EOL%    oe_GroundCover_texCoord = vec2(1,1);%EOL%    vp_Normal = Rnormal;%EOL%    gl_Position = UR;%EOL%    VP_EmitViewVertex();%EOL%                    %EOL%    EndPrimitive();%EOL%    %EOL%#endif // !OE_IS_SHADOW_CAMERA%EOL%}%EOL%%EOL%";

    GroundCover_FS = "GroundCover.FS.glsl";
    _sources[GroundCover_FS] = "#version $GLSL_VERSION_STR%EOL%#pragma vp_name       Land cover billboard texture application%EOL%#pragma vp_entryPoint oe_GroundCover_fragment%EOL%#pragma vp_location   fragment_coloring%EOL%%EOL%#pragma import_defines(OE_GROUNDCOVER_HAS_MULTISAMPLES)%EOL%#pragma import_defines(OE_GROUNDCOVER_SHOW_TESSELLATION)%EOL%%EOL%%EOL%uniform sampler2DArray oe_GroundCover_billboardTex;%EOL%uniform float oe_GroundCover_exposure;%EOL%in vec2 oe_GroundCover_texCoord;%EOL%in vec4 oe_layer_tilec;%EOL%%EOL%flat in float oe_GroundCover_arrayIndex; // from GroundCover.GS.glsl%EOL%%EOL%void oe_GroundCover_fragment(inout vec4 color)%EOL%{    %EOL%#ifdef OE_GROUNDCOVER_SHOW_TESSELLATION%EOL%    color = vec4(1,1,1,1);%EOL%    return;%EOL%#endif%EOL%%EOL%    // modulate the texture%EOL%    color = texture(oe_GroundCover_billboardTex, vec3(oe_GroundCover_texCoord, oe_GroundCover_arrayIndex)) * color;%EOL%    color.rgb *= oe_GroundCover_exposure;%EOL%    %EOL%    // if multisampling is off, use alpha-discard.%EOL%#ifndef OE_GROUNDCOVER_HAS_MULTISAMPLES%EOL%    if (color.a < 0.15)%EOL%        discard;%EOL%#endif%EOL%    //if ( !oe_terrain_hasMultiSamples && color.a < 0.15 )%EOL%    //    discard;%EOL%}%EOL%%EOL%";
}
